"use client";
import {
  __webpack_exports__AnnotationLayer,
  __webpack_exports__TextLayer,
  __webpack_exports__getDocument
} from "./chunk-V4WT7RYS.js";
import {
  require_jsx_runtime
} from "./chunk-CONWV326.js";
import {
  require_react_dom
} from "./chunk-S7A2XGMU.js";
import {
  require_react
} from "./chunk-IRI276S4.js";
import {
  __publicField,
  __toESM
} from "./chunk-QWN5BXRD.js";

// node_modules/.pnpm/@anaralabs+lector@3.7.2_@types+react@18.3.26_pdfjs-dist@4.10.38_react@19.2.0/node_modules/@anaralabs/lector/dist/index.js
var import_react5 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());

// node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React2 = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node);
  }
  const e2 = event;
  return e2.target != null && node.contains(e2.target);
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

// node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/.pnpm/tabbable@6.3.0/node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/.pnpm/@floating-ui+core@1.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getBoundingRect(rects) {
  const minX = min(...rects.map((rect) => rect.left));
  const minY = min(...rects.map((rect) => rect.top));
  const maxX = max(...rects.map((rect) => rect.right));
  const maxY = max(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a2, b) => a2.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i2 = 0; i2 < sortedRects.length; i2++) {
    const rect = sortedRects[i2];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
var inline = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state;
      const {
        padding = 2,
        x,
        y
      } = evaluate(options, state);
      const nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          return clientRects.find((rect) => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max(...clientRects.map((rect) => rect.right));
          const minLeft = min(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};

// node_modules/.pnpm/@floating-ui+dom@1.7.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b) {
  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId2;
  const root = getDocumentElement(element);
  function cleanup2() {
    var _io;
    clearTimeout(timeoutId2);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup2();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId2 = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup2;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var inline2 = inline;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/.pnpm/@floating-ui+react-dom@2.1.6_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? import_react.useLayoutEffect : noop;
function deepEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (typeof a2 !== typeof b) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys;
  if (a2 && b && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var inline3 = (options, deps) => ({
  ...inline2(options),
  options: [options, deps]
});

// node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
function useMergeRefs(refs) {
  return React2.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
var SafeReact = {
  ...React2
};
var useInsertionEffect = SafeReact.useInsertionEffect;
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React2.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React2.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
function isDifferentRow(index3, cols, prevRow) {
  return Math.floor(index3 / cols) !== prevRow;
}
function isIndexOutOfBounds(listRef, index3) {
  return index3 < 0 || index3 >= listRef.current.length;
}
function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}
function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index3 = startingIndex;
  do {
    index3 += decrement ? -amount : amount;
  } while (index3 >= 0 && index3 <= list.length - 1 && isDisabled(list, index3, disabledIndices));
  return index3;
}
function getGridNavigatedIndex(elementsRef, _ref) {
  let {
    event,
    orientation,
    loop,
    rtl,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset4 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset4 : offset4 - cols;
        }
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function buildCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes.forEach((_ref2, index3) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index3 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i2 = 0; i2 < width; i2++) {
        for (let j = 0; j < height; j++) {
          targetCells.push(startIndex + i2 + j * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index3;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getCellIndexOfCorner(index3, sizes, cellMap, cols, corner) {
  if (index3 === -1) return -1;
  const firstCellIndex = cellMap.indexOf(index3);
  const sizeItem = sizes[index3];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index3);
  }
}
function getCellIndices(indices, cellMap) {
  return cellMap.flatMap((index3, cellIndex) => indices.includes(index3) ? [cellIndex] : []);
}
function isDisabled(list, index3, disabledIndices) {
  if (disabledIndices) {
    return disabledIndices.includes(index3);
  }
  const element = list[index3];
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
var index2 = typeof document !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
function sortByDocumentPosition(a2, b) {
  const position = a2.compareDocumentPosition(b);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
function areMapsEqual(map1, map2) {
  if (map1.size !== map2.size) {
    return false;
  }
  for (const [key, value] of map1.entries()) {
    if (value !== map2.get(key)) {
      return false;
    }
  }
  return true;
}
var FloatingListContext = React2.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [map, setMap] = React2.useState(() => /* @__PURE__ */ new Map());
  const register = React2.useCallback((node) => {
    setMap((prevMap) => new Map(prevMap).set(node, null));
  }, []);
  const unregister = React2.useCallback((node) => {
    setMap((prevMap) => {
      const map2 = new Map(prevMap);
      map2.delete(node);
      return map2;
    });
  }, []);
  index2(() => {
    const newMap = new Map(map);
    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);
    nodes.forEach((node, index3) => {
      newMap.set(node, index3);
    });
    if (!areMapsEqual(map, newMap)) {
      setMap(newMap);
    }
  }, [map]);
  return React2.createElement(FloatingListContext.Provider, {
    value: React2.useMemo(() => ({
      register,
      unregister,
      map,
      elementsRef,
      labelsRef
    }), [register, unregister, map, elementsRef, labelsRef])
  }, children);
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label
  } = props;
  const {
    register,
    unregister,
    map,
    elementsRef,
    labelsRef
  } = React2.useContext(FloatingListContext);
  const [index$1, setIndex] = React2.useState(null);
  const componentRef = React2.useRef(null);
  const ref = React2.useCallback((node) => {
    componentRef.current = node;
    if (index$1 !== null) {
      elementsRef.current[index$1] = node;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index$1, elementsRef, labelsRef, label]);
  index2(() => {
    const node = componentRef.current;
    if (node) {
      register(node);
      return () => {
        unregister(node);
      };
    }
  }, [register, unregister]);
  index2(() => {
    const index3 = componentRef.current ? map.get(componentRef.current) : null;
    if (index3 != null) {
      setIndex(index3);
    }
  }, [map]);
  return React2.useMemo(() => ({
    ref,
    index: index$1 == null ? -1 : index$1
  }), [index$1, ref]);
}
function renderJsx(render, computedProps) {
  if (typeof render === "function") {
    return render(computedProps);
  }
  if (render) {
    return React2.cloneElement(render, computedProps);
  }
  return React2.createElement("div", computedProps);
}
var CompositeContext = React2.createContext({
  activeIndex: 0,
  onNavigate: () => {
  }
});
var horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
var verticalKeys = [ARROW_UP, ARROW_DOWN];
var allKeys = [...horizontalKeys, ...verticalKeys];
var Composite = React2.forwardRef(function Composite2(props, forwardedRef) {
  const {
    render,
    orientation = "both",
    loop = true,
    rtl = false,
    cols = 1,
    disabledIndices,
    activeIndex: externalActiveIndex,
    onNavigate: externalSetActiveIndex,
    itemSizes,
    dense = false,
    ...domProps
  } = props;
  const [internalActiveIndex, internalSetActiveIndex] = React2.useState(0);
  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
  const elementsRef = React2.useRef([]);
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const contextValue = React2.useMemo(() => ({
    activeIndex,
    onNavigate
  }), [activeIndex, onNavigate]);
  const isGrid = cols > 1;
  function handleKeyDown(event) {
    if (!allKeys.includes(event.key)) return;
    let nextIndex = activeIndex;
    const minIndex = getMinIndex(elementsRef, disabledIndices);
    const maxIndex = getMaxIndex(elementsRef, disabledIndices);
    const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;
    const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;
    if (isGrid) {
      const sizes = itemSizes || Array.from({
        length: elementsRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = buildCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index3) => index3 != null && !isDisabled(elementsRef.current, index3, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index3, cellIndex) => index3 != null && !isDisabled(elementsRef.current, index3, disabledIndices) ? cellIndex : foundIndex, -1);
      const maybeNextIndex = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getCellIndices([...disabledIndices || elementsRef.current.map((_, index3) => isDisabled(elementsRef.current, index3) ? index3 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getCellIndexOfCorner(
          activeIndex > maxIndex ? minIndex : activeIndex,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN ? "bl" : event.key === horizontalEndKey ? "tr" : "tl"
        )
      })];
      if (maybeNextIndex != null) {
        nextIndex = maybeNextIndex;
      }
    }
    const toEndKeys = {
      horizontal: [horizontalEndKey],
      vertical: [ARROW_DOWN],
      both: [horizontalEndKey, ARROW_DOWN]
    }[orientation];
    const toStartKeys = {
      horizontal: [horizontalStartKey],
      vertical: [ARROW_UP],
      both: [horizontalStartKey, ARROW_UP]
    }[orientation];
    const preventedKeys = isGrid ? allKeys : {
      horizontal: horizontalKeys,
      vertical: verticalKeys,
      both: allKeys
    }[orientation];
    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
        nextIndex = minIndex;
      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: nextIndex,
          decrement: toStartKeys.includes(event.key),
          disabledIndices
        });
      }
    }
    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {
      var _elementsRef$current$;
      event.stopPropagation();
      if (preventedKeys.includes(event.key)) {
        event.preventDefault();
      }
      onNavigate(nextIndex);
      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();
    }
  }
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: forwardedRef,
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    onKeyDown(e2) {
      domProps.onKeyDown == null || domProps.onKeyDown(e2);
      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e2);
      handleKeyDown(e2);
    }
  };
  return React2.createElement(CompositeContext.Provider, {
    value: contextValue
  }, React2.createElement(FloatingList, {
    elementsRef
  }, renderJsx(render, computedProps)));
});
var CompositeItem = React2.forwardRef(function CompositeItem2(props, forwardedRef) {
  const {
    render,
    ...domProps
  } = props;
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const {
    activeIndex,
    onNavigate
  } = React2.useContext(CompositeContext);
  const {
    ref,
    index: index3
  } = useListItem();
  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
  const isActive = activeIndex === index3;
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: mergedRef,
    tabIndex: isActive ? 0 : -1,
    "data-active": isActive ? "" : void 0,
    onFocus(e2) {
      domProps.onFocus == null || domProps.onFocus(e2);
      renderElementProps.onFocus == null || renderElementProps.onFocus(e2);
      onNavigate(index3);
    }
  };
  return renderJsx(render, computedProps);
});
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var serverHandoffComplete = false;
var count = 0;
var genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = React2.useState(() => serverHandoffComplete ? genId() : void 0);
  index2(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React2.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
var useReactId = SafeReact.useId;
var useId = useReactId || useFloatingId;
var devMessageSet;
if (true) {
  devMessageSet = /* @__PURE__ */ new Set();
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
    console.warn(message);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
    console.error(message);
  }
}
var FloatingArrow = React2.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow4,
        shift: shift4
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d,
    style: {
      transform,
      ...restStyle
    } = {},
    ...rest
  } = props;
  if (true) {
    if (!ref) {
      warn("The `ref` prop is required for `FloatingArrow`.");
    }
  }
  const clipPathId = useId();
  const [isRTL2, setIsRTL] = React2.useState(false);
  index2(() => {
    if (!floating) return;
    const isRTL3 = getComputedStyle2(floating).direction === "rtl";
    if (isRTL3) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift4 != null && shift4.x || !isVerticalSide && shift4 != null && shift4.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow4 == null ? void 0 : arrow4.x) != null ? computedStaticOffset || arrow4.x : "";
  const arrowY = (arrow4 == null ? void 0 : arrow4.y) != null ? computedStaticOffset || arrow4.y : "";
  const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return React2.createElement("svg", _extends({}, rest, {
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform].filter((t2) => !!t2).join(" "),
      ...restStyle
    }
  }), computedStrokeWidth > 0 && React2.createElement("path", {
    clipPath: "url(#" + clipPathId + ")",
    fill: "none",
    stroke,
    strokeWidth: computedStrokeWidth + (d ? 0 : 1),
    d: dValue
  }), React2.createElement("path", {
    stroke: computedStrokeWidth && !d ? rest.fill : "none",
    d: dValue
  }), React2.createElement("clipPath", {
    id: clipPathId
  }, React2.createElement("rect", {
    x: -halfStrokeWidth,
    y: halfStrokeWidth * (isCustomShape ? -1 : 1),
    width: width + computedStrokeWidth,
    height: width
  })));
});
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l) => l !== listener)) || []);
    }
  };
}
var FloatingNodeContext = React2.createContext(null);
var FloatingTreeContext = React2.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React2.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => React2.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
var safePolygonIdentifier = createAttribute("safe-polygon");
var NOOP = () => {
};
var FloatingDelayGroupContext = React2.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
function getChildren(nodes, id) {
  let allChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  });
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = nodes.filter((node) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n2) => {
        var _node$context2;
        return node.parentId === n2.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    });
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
var FocusGuard = React2.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = React2.useState();
  index2(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return React2.createElement("span", _extends({}, props, restProps));
});
var PortalContext = React2.createContext(null);
var attr = createAttribute("portal");
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
var VisuallyHiddenDismiss = React2.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return React2.createElement("button", _extends({}, props, {
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
var lockCount = 0;
function enableScrollLock() {
  const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());
  const bodyStyle = document.body.style;
  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
  const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
  bodyStyle.overflow = "hidden";
  if (scrollbarWidth) {
    bodyStyle[paddingProp] = scrollbarWidth + "px";
  }
  if (isIOS) {
    var _window$visualViewpor, _window$visualViewpor2;
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    Object.assign(bodyStyle, {
      position: "fixed",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0"
    });
  }
  return () => {
    Object.assign(bodyStyle, {
      overflow: "",
      [paddingProp]: ""
    });
    if (isIOS) {
      Object.assign(bodyStyle, {
        position: "",
        top: "",
        left: "",
        right: ""
      });
      window.scrollTo(scrollX, scrollY);
    }
  };
}
var cleanup = () => {
};
var FloatingOverlay = React2.forwardRef(function FloatingOverlay2(props, ref) {
  const {
    lockScroll = false,
    ...rest
  } = props;
  index2(() => {
    if (!lockScroll) return;
    lockCount++;
    if (lockCount === 1) {
      cleanup = enableScrollLock();
    }
    return () => {
      lockCount--;
      if (lockCount === 0) {
        cleanup();
      }
    };
  }, [lockScroll]);
  return React2.createElement("div", _extends({
    ref
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
var bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
};
var captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
};
var normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
    outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
  };
};
function useDismiss(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles,
    capture
  } = props;
  const tree = useFloatingTree();
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const insideReactTreeRef = React2.useRef(false);
  const endedOrStartedInsideRef = React2.useRef(false);
  const {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles);
  const {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture);
  const isComposingRef = React2.useRef(false);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    if (isComposingRef.current) {
      return;
    }
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  });
  const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event);
      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = false;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    endedOrStartedInsideRef.current = false;
    if (outsidePressEvent === "click" && endedOrStartedInside) {
      return;
    }
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget(event);
    const inertSelector = "[" + createAttribute("inert") + "]";
    const markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {
        break;
      }
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))) {
      return;
    }
    if (isHTMLElement(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY) {
        const isRTL2 = getComputedStyle2(target).direction === "rtl";
        if (isRTL2) {
          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
        }
      }
      if (xCond || canScrollX && event.offsetY > target.clientHeight) {
        return;
      }
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    onOpenChange(false, event, "outside-press");
  });
  const closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event);
      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React2.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(false, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout);
      isComposingRef.current = true;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(
        () => {
          isComposingRef.current = false;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0
      );
    }
    const doc = getDocument(elements.floating);
    if (escapeKey) {
      doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
      doc.addEventListener("compositionstart", handleCompositionStart);
      doc.addEventListener("compositionend", handleCompositionEnd);
    }
    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement(elements.domReference)) {
        ancestors = getOverflowAncestors(elements.domReference);
      }
      if (isElement(elements.floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.floating));
      }
      if (!isElement(elements.reference) && elements.reference && elements.reference.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      if (escapeKey) {
        doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
        doc.removeEventListener("compositionstart", handleCompositionStart);
        doc.removeEventListener("compositionend", handleCompositionEnd);
      }
      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
      window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
  React2.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  const reference = React2.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    [bubbleHandlerKeys[referencePressEvent]]: (event) => {
      if (referencePress) {
        onOpenChange(false, event.nativeEvent, "reference-press");
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);
  const floating = React2.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = true;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = true;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      insideReactTreeRef.current = true;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent]);
  return React2.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = React2.useRef({});
  const [events] = React2.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  if (true) {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React2.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React2.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React2.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React2.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React2.useState(null);
  const [positionReference, _setPositionReference] = React2.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React2.useRef(null);
  const tree = useFloatingTree();
  index2(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React2.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = React2.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React2.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React2.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = React2.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index2(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React2.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = React2.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React2.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React2.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React2.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}

// node_modules/.pnpm/zustand@5.0.8_@types+react@18.3.26_react@19.2.0/node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/.pnpm/zustand@5.0.8_@types+react@18.3.26_react@19.2.0/node_modules/zustand/esm/react.mjs
var import_react3 = __toESM(require_react(), 1);
var identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = import_react3.default.useSyncExternalStore(
    api.subscribe,
    import_react3.default.useCallback(() => selector(api.getState()), [api, selector]),
    import_react3.default.useCallback(() => selector(api.getInitialState()), [api, selector])
  );
  import_react3.default.useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// node_modules/.pnpm/@anaralabs+lector@3.7.2_@types+react@18.3.26_pdfjs-dist@4.10.38_react@19.2.0/node_modules/@anaralabs/lector/dist/index.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/use-debounce@10.0.6_react@19.2.0/node_modules/use-debounce/dist/index.module.js
var import_react4 = __toESM(require_react());
function c(e2, u2, c2, i2) {
  var a2 = this, o = (0, import_react4.useRef)(null), f2 = (0, import_react4.useRef)(0), l = (0, import_react4.useRef)(0), v = (0, import_react4.useRef)(null), m = (0, import_react4.useRef)([]), d = (0, import_react4.useRef)(), g = (0, import_react4.useRef)(), p = (0, import_react4.useRef)(e2), w = (0, import_react4.useRef)(true);
  p.current = e2;
  var s = "undefined" != typeof window, x = !u2 && 0 !== u2 && s;
  if ("function" != typeof e2) throw new TypeError("Expected a function");
  u2 = +u2 || 0;
  var h = !!(c2 = c2 || {}).leading, y = !("trailing" in c2) || !!c2.trailing, F = "maxWait" in c2, A = "debounceOnServer" in c2 && !!c2.debounceOnServer, D = F ? Math.max(+c2.maxWait || 0, u2) : null;
  (0, import_react4.useEffect)(function() {
    return w.current = true, function() {
      w.current = false;
    };
  }, []);
  var T = (0, import_react4.useMemo)(function() {
    var r3 = function(r4) {
      var n3 = m.current, t3 = d.current;
      return m.current = d.current = null, f2.current = r4, l.current = l.current || r4, g.current = p.current.apply(t3, n3);
    }, n2 = function(r4, n3) {
      x && cancelAnimationFrame(v.current), v.current = x ? requestAnimationFrame(r4) : setTimeout(r4, n3);
    }, t2 = function(r4) {
      if (!w.current) return false;
      var n3 = r4 - o.current;
      return !o.current || n3 >= u2 || n3 < 0 || F && r4 - f2.current >= D;
    }, e3 = function(n3) {
      return v.current = null, y && m.current ? r3(n3) : (m.current = d.current = null, g.current);
    }, c3 = function r4() {
      var c4 = Date.now();
      if (h && l.current === f2.current && T2(), t2(c4)) return e3(c4);
      if (w.current) {
        var i3 = u2 - (c4 - o.current), a3 = F ? Math.min(i3, D - (c4 - f2.current)) : i3;
        n2(r4, a3);
      }
    }, T2 = function() {
      i2 && i2({});
    }, W = function() {
      if (s || A) {
        var e4 = Date.now(), i3 = t2(e4);
        if (m.current = [].slice.call(arguments), d.current = a2, o.current = e4, i3) {
          if (!v.current && w.current) return f2.current = o.current, n2(c3, u2), h ? r3(o.current) : g.current;
          if (F) return n2(c3, u2), r3(o.current);
        }
        return v.current || n2(c3, u2), g.current;
      }
    };
    return W.cancel = function() {
      var r4 = v.current;
      r4 && (x ? cancelAnimationFrame(v.current) : clearTimeout(v.current)), f2.current = 0, m.current = o.current = d.current = v.current = null, r4 && i2 && i2({});
    }, W.isPending = function() {
      return !!v.current;
    }, W.flush = function() {
      return v.current ? e3(Date.now()) : g.current;
    }, W;
  }, [h, F, u2, D, y, x, s, A, i2]);
  return T;
}
function i(r3, n2) {
  return r3 === n2;
}
function a(n2, t2, a2) {
  var o = a2 && a2.equalityFn || i, f2 = (0, import_react4.useRef)(n2), l = (0, import_react4.useState)({})[1], v = c((0, import_react4.useCallback)(function(r3) {
    f2.current = r3, l({});
  }, [l]), t2, a2, l), m = (0, import_react4.useRef)(n2);
  return o(m.current, n2) || (v(n2), m.current = n2), [f2.current, v];
}

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default = parse;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset4 = 0) {
  return (byteToHex[arr[offset4 + 0]] + byteToHex[arr[offset4 + 1]] + byteToHex[arr[offset4 + 2]] + byteToHex[arr[offset4 + 3]] + "-" + byteToHex[arr[offset4 + 4]] + byteToHex[arr[offset4 + 5]] + "-" + byteToHex[arr[offset4 + 6]] + byteToHex[arr[offset4 + 7]] + "-" + byteToHex[arr[offset4 + 8]] + byteToHex[arr[offset4 + 9]] + "-" + byteToHex[arr[offset4 + 10]] + byteToHex[arr[offset4 + 11]] + byteToHex[arr[offset4 + 12]] + byteToHex[arr[offset4 + 13]] + byteToHex[arr[offset4 + 14]] + byteToHex[arr[offset4 + 15]]).toLowerCase();
}

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i2 = 0; i2 < input.length * 4; i2++) {
    bytes[i2] = input[i2 >> 2] >>> i2 % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a2 = 1732584193;
  let b = -271733879;
  let c2 = -1732584194;
  let d = 271733878;
  for (let i2 = 0; i2 < x.length; i2 += 16) {
    const olda = a2;
    const oldb = b;
    const oldc = c2;
    const oldd = d;
    a2 = md5ff(a2, b, c2, d, x[i2], 7, -680876936);
    d = md5ff(d, a2, b, c2, x[i2 + 1], 12, -389564586);
    c2 = md5ff(c2, d, a2, b, x[i2 + 2], 17, 606105819);
    b = md5ff(b, c2, d, a2, x[i2 + 3], 22, -1044525330);
    a2 = md5ff(a2, b, c2, d, x[i2 + 4], 7, -176418897);
    d = md5ff(d, a2, b, c2, x[i2 + 5], 12, 1200080426);
    c2 = md5ff(c2, d, a2, b, x[i2 + 6], 17, -1473231341);
    b = md5ff(b, c2, d, a2, x[i2 + 7], 22, -45705983);
    a2 = md5ff(a2, b, c2, d, x[i2 + 8], 7, 1770035416);
    d = md5ff(d, a2, b, c2, x[i2 + 9], 12, -1958414417);
    c2 = md5ff(c2, d, a2, b, x[i2 + 10], 17, -42063);
    b = md5ff(b, c2, d, a2, x[i2 + 11], 22, -1990404162);
    a2 = md5ff(a2, b, c2, d, x[i2 + 12], 7, 1804603682);
    d = md5ff(d, a2, b, c2, x[i2 + 13], 12, -40341101);
    c2 = md5ff(c2, d, a2, b, x[i2 + 14], 17, -1502002290);
    b = md5ff(b, c2, d, a2, x[i2 + 15], 22, 1236535329);
    a2 = md5gg(a2, b, c2, d, x[i2 + 1], 5, -165796510);
    d = md5gg(d, a2, b, c2, x[i2 + 6], 9, -1069501632);
    c2 = md5gg(c2, d, a2, b, x[i2 + 11], 14, 643717713);
    b = md5gg(b, c2, d, a2, x[i2], 20, -373897302);
    a2 = md5gg(a2, b, c2, d, x[i2 + 5], 5, -701558691);
    d = md5gg(d, a2, b, c2, x[i2 + 10], 9, 38016083);
    c2 = md5gg(c2, d, a2, b, x[i2 + 15], 14, -660478335);
    b = md5gg(b, c2, d, a2, x[i2 + 4], 20, -405537848);
    a2 = md5gg(a2, b, c2, d, x[i2 + 9], 5, 568446438);
    d = md5gg(d, a2, b, c2, x[i2 + 14], 9, -1019803690);
    c2 = md5gg(c2, d, a2, b, x[i2 + 3], 14, -187363961);
    b = md5gg(b, c2, d, a2, x[i2 + 8], 20, 1163531501);
    a2 = md5gg(a2, b, c2, d, x[i2 + 13], 5, -1444681467);
    d = md5gg(d, a2, b, c2, x[i2 + 2], 9, -51403784);
    c2 = md5gg(c2, d, a2, b, x[i2 + 7], 14, 1735328473);
    b = md5gg(b, c2, d, a2, x[i2 + 12], 20, -1926607734);
    a2 = md5hh(a2, b, c2, d, x[i2 + 5], 4, -378558);
    d = md5hh(d, a2, b, c2, x[i2 + 8], 11, -2022574463);
    c2 = md5hh(c2, d, a2, b, x[i2 + 11], 16, 1839030562);
    b = md5hh(b, c2, d, a2, x[i2 + 14], 23, -35309556);
    a2 = md5hh(a2, b, c2, d, x[i2 + 1], 4, -1530992060);
    d = md5hh(d, a2, b, c2, x[i2 + 4], 11, 1272893353);
    c2 = md5hh(c2, d, a2, b, x[i2 + 7], 16, -155497632);
    b = md5hh(b, c2, d, a2, x[i2 + 10], 23, -1094730640);
    a2 = md5hh(a2, b, c2, d, x[i2 + 13], 4, 681279174);
    d = md5hh(d, a2, b, c2, x[i2], 11, -358537222);
    c2 = md5hh(c2, d, a2, b, x[i2 + 3], 16, -722521979);
    b = md5hh(b, c2, d, a2, x[i2 + 6], 23, 76029189);
    a2 = md5hh(a2, b, c2, d, x[i2 + 9], 4, -640364487);
    d = md5hh(d, a2, b, c2, x[i2 + 12], 11, -421815835);
    c2 = md5hh(c2, d, a2, b, x[i2 + 15], 16, 530742520);
    b = md5hh(b, c2, d, a2, x[i2 + 2], 23, -995338651);
    a2 = md5ii(a2, b, c2, d, x[i2], 6, -198630844);
    d = md5ii(d, a2, b, c2, x[i2 + 7], 10, 1126891415);
    c2 = md5ii(c2, d, a2, b, x[i2 + 14], 15, -1416354905);
    b = md5ii(b, c2, d, a2, x[i2 + 5], 21, -57434055);
    a2 = md5ii(a2, b, c2, d, x[i2 + 12], 6, 1700485571);
    d = md5ii(d, a2, b, c2, x[i2 + 3], 10, -1894986606);
    c2 = md5ii(c2, d, a2, b, x[i2 + 10], 15, -1051523);
    b = md5ii(b, c2, d, a2, x[i2 + 1], 21, -2054922799);
    a2 = md5ii(a2, b, c2, d, x[i2 + 8], 6, 1873313359);
    d = md5ii(d, a2, b, c2, x[i2 + 15], 10, -30611744);
    c2 = md5ii(c2, d, a2, b, x[i2 + 6], 15, -1560198380);
    b = md5ii(b, c2, d, a2, x[i2 + 13], 21, 1309151649);
    a2 = md5ii(a2, b, c2, d, x[i2 + 4], 6, -145523070);
    d = md5ii(d, a2, b, c2, x[i2 + 11], 10, -1120210379);
    c2 = md5ii(c2, d, a2, b, x[i2 + 2], 15, 718787259);
    b = md5ii(b, c2, d, a2, x[i2 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b = safeAdd(b, oldb);
    c2 = safeAdd(c2, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a2, b, c2, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i2 = 0; i2 < input.length; i2++) {
    output[i2 >> 2] |= (input[i2] & 255) << i2 % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a2, b, x, s, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x, t2)), s), b);
}
function md5ff(a2, b, c2, d, x, s, t2) {
  return md5cmn(b & c2 | ~b & d, a2, b, x, s, t2);
}
function md5gg(a2, b, c2, d, x, s, t2) {
  return md5cmn(b & d | c2 & ~d, a2, b, x, s, t2);
}
function md5hh(a2, b, c2, d, x, s, t2) {
  return md5cmn(b ^ c2 ^ d, a2, b, x, s, t2);
}
function md5ii(a2, b, c2, d, x, s, t2) {
  return md5cmn(c2 ^ (b | ~d), a2, b, x, s, t2);
}
var md5_default = md5;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i2 = 0; i2 < str.length; ++i2) {
    bytes[i2] = str.charCodeAt(i2);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash, value, namespace, buf, offset4) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset4 = offset4 || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset4 + i2] = bytes[i2];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset4) {
  return v35(48, md5_default, value, namespace, buf, offset4);
}
v3.DNS = DNS;
v3.URL = URL;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset4) {
  var _a;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset4 = offset4 || 0;
    if (offset4 < 0 || offset4 + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset4}:${offset4 + 15} is out of buffer bounds`);
    }
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset4 + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i2 = 0; i2 < N; ++i2) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i2 * 64 + j * 4] << 24 | bytes[i2 * 64 + j * 4 + 1] << 16 | bytes[i2 * 64 + j * 4 + 2] << 8 | bytes[i2 * 64 + j * 4 + 3];
    }
    M[i2] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i2 = 0; i2 < N; ++i2) {
    const W = new Uint32Array(80);
    for (let t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[i2][t2];
    }
    for (let t2 = 16; t2 < 80; ++t2) {
      W[t2] = ROTL(W[t2 - 3] ^ W[t2 - 8] ^ W[t2 - 14] ^ W[t2 - 16], 1);
    }
    let a2 = H[0];
    let b = H[1];
    let c2 = H[2];
    let d = H[3];
    let e2 = H[4];
    for (let t2 = 0; t2 < 80; ++t2) {
      const s = Math.floor(t2 / 20);
      const T = ROTL(a2, 5) + f(s, b, c2, d) + e2 + K[s] + W[t2] >>> 0;
      e2 = d;
      d = c2;
      c2 = ROTL(b, 30) >>> 0;
      b = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c2 >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e2 >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default = sha1;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset4) {
  return v35(80, sha1_default, value, namespace, buf, offset4);
}
v5.DNS = DNS;
v5.URL = URL;

// node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@18.3.26_react@19.2.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var React5 = __toESM(require_react(), 1);

// node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@18.3.26_react@19.2.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React4 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup2 = setRef(ref, node);
      if (!hasCleanup && typeof cleanup2 == "function") {
        hasCleanup = true;
      }
      return cleanup2;
    });
    if (hasCleanup) {
      return () => {
        for (let i2 = 0; i2 < cleanups.length; i2++) {
          const cleanup2 = cleanups[i2];
          if (typeof cleanup2 == "function") {
            cleanup2();
          } else {
            setRef(refs[i2], null);
          }
        }
      };
    }
  };
}

// node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@18.3.26_react@19.2.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot2 = React5.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React5.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React5.Children.count(newElement) > 1) return React5.Children.only(null);
          return React5.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React5.isValidElement(newElement) ? React5.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React5.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React5.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps2(slotProps, children.props);
      if (children.type !== React5.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React5.cloneElement(children, props2);
    }
    return React5.Children.count(children) > 1 ? React5.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React5.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/.pnpm/@tanstack+react-virtual@3.13.12_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@tanstack/react-virtual/dist/esm/index.js
var React6 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/.pnpm/@tanstack+virtual-core@3.13.12/node_modules/@tanstack/virtual-core/dist/esm/utils.js
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  function memoizedFunction() {
    var _a, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index3) => deps[index3] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);
    return result;
  }
  memoizedFunction.updateDeps = (newDeps) => {
    deps = newDeps;
  };
  return memoizedFunction;
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
  } else {
    return value;
  }
}
var approxEqual = (a2, b) => Math.abs(a2 - b) < 1.01;
var debounce = (targetWindow, fn, ms) => {
  let timeoutId2;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId2);
    timeoutId2 = targetWindow.setTimeout(() => fn.apply(this, args), ms);
  };
};

// node_modules/.pnpm/@tanstack+virtual-core@3.13.12/node_modules/@tanstack/virtual-core/dist/esm/index.js
var getRect = (element) => {
  const { offsetWidth, offsetHeight } = element;
  return { width: offsetWidth, height: offsetHeight };
};
var defaultKeyExtractor = (index3) => index3;
var defaultRangeExtractor = (range) => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i2 = start; i2 <= end; i2++) {
    arr.push(i2);
  }
  return arr;
};
var observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(getRect(element));
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(getRect(element));
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
var addEventListenerOptions = {
  passive: true
};
var supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
var observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset4 = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset4, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset4 = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback();
    cb(offset4, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
var measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size4 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size4;
    }
  }
  return element[instance.options.horizontal ? "offsetWidth" : "offsetHeight"];
};
var elementScroll = (offset4, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset4 + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
var Virtualizer = class {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a;
          (_a = get()) == null ? void 0 : _a.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined") delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a, _b;
      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d) => d());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset4, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset4 ? "forward" : "backward" : null;
            this.scrollOffset = offset4;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index3) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m = index3 - 1; m >= 0; m--) {
        const measurement = measurements[m];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a2, b) => {
        if (a2.end === b.end) {
          return a2.index - b.index;
        }
        return a2.end - b.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count2, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count: count2,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: count2, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min2 = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min2);
        for (let i2 = min2; i2 < count2; i2++) {
          const key = getItemKey(i2);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i2 - 1] : this.getFurthestMeasurement(measurements, i2);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size4 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i2);
          const end = start + size4;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i2 % this.options.lanes;
          measurements[i2] = {
            index: i2,
            start,
            size: size4,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: "getMeasurements",
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key: "calculateRange",
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range = this.calculateRange();
        if (range) {
          startIndex = range.startIndex;
          endIndex = range.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count2, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count: count2
        });
      },
      {
        key: "getVirtualIndexes",
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const index3 = this.indexFromElement(node);
      const item = this.measurementsCache[index3];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.elementsCache.set(key, node);
      }
      if (node.isConnected) {
        this.resizeItem(index3, this.options.measureElement(node, entry, this));
      }
    };
    this.resizeItem = (index3, size4) => {
      const item = this.measurementsCache[index3];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size4 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (this.options.debug) {
            console.info("correction", delta);
          }
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size4));
        this.notify(false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k = 0, len = indexes.length; k < len; k++) {
          const i2 = indexes[k];
          const measurement = measurements[i2];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: "getVirtualItems",
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset4) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index3) => notUndefined(measurements[index3]).start,
          offset4
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size4 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size4 ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size4) / 2;
      } else if (align === "end") {
        toOffset -= size4;
      }
      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size4;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index3, align = "auto") => {
      index3 = Math.max(0, Math.min(index3, this.options.count - 1));
      const item = this.measurementsCache[index3];
      if (!item) {
        return void 0;
      }
      const size4 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size4 - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index3, { align: initialAlign = "auto", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      index3 = Math.max(0, Math.min(index3, this.options.count - 1));
      let attempts = 0;
      const maxAttempts = 10;
      const tryScroll = (currentAlign) => {
        if (!this.targetWindow) return;
        const offsetInfo = this.getOffsetForIndex(index3, currentAlign);
        if (!offsetInfo) {
          console.warn("Failed to get offset for index:", index3);
          return;
        }
        const [offset4, align] = offsetInfo;
        this._scrollToOffset(offset4, { adjustments: void 0, behavior });
        this.targetWindow.requestAnimationFrame(() => {
          const currentOffset = this.getScrollOffset();
          const afterInfo = this.getOffsetForIndex(index3, align);
          if (!afterInfo) {
            console.warn("Failed to get offset for index:", index3);
            return;
          }
          if (!approxEqual(afterInfo[0], currentOffset)) {
            scheduleRetry(align);
          }
        });
      };
      const scheduleRetry = (align) => {
        if (!this.targetWindow) return;
        attempts++;
        if (attempts < maxAttempts) {
          if (this.options.debug) {
            console.info("Schedule retry", attempts, maxAttempts);
          }
          this.targetWindow.requestAnimationFrame(() => tryScroll(align));
        } else {
          console.warn(
            `Failed to scroll to index ${index3} after ${maxAttempts} attempts.`
          );
        }
      };
      tryScroll(initialAlign);
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex >= 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset4, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset4, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
};
var findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset = (index3) => measurements[index3].start;
  if (measurements.length <= lanes) {
    return {
      startIndex: 0,
      endIndex: lastIndex
    };
  }
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}

// node_modules/.pnpm/@tanstack+react-virtual@3.13.12_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@tanstack/react-virtual/dist/esm/index.js
var useIsomorphicLayoutEffect = typeof document !== "undefined" ? React6.useLayoutEffect : React6.useEffect;
function useVirtualizerBase(options) {
  const rerender = React6.useReducer(() => ({}), {})[1];
  const resolvedOptions = {
    ...options,
    onChange: (instance2, sync) => {
      var _a;
      if (sync) {
        (0, import_react_dom3.flushSync)(rerender);
      } else {
        rerender();
      }
      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);
    }
  };
  const [instance] = React6.useState(
    () => new Virtualizer(resolvedOptions)
  );
  instance.setOptions(resolvedOptions);
  useIsomorphicLayoutEffect(() => {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect(() => {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll,
    ...options
  });
}

// node_modules/.pnpm/@anaralabs+lector@3.7.2_@types+react@18.3.26_pdfjs-dist@4.10.38_react@19.2.0/node_modules/@anaralabs/lector/dist/index.js
var clamp2 = (value, minimum, maximum) => {
  return Math.min(Math.max(value, minimum), maximum);
};
var getFitWidthZoom = (containerWidth, viewports, zoomOptions) => {
  const { minZoom, maxZoom } = zoomOptions;
  const maxPageWidth = Math.max(...viewports.map((viewport) => viewport.width));
  const targetZoom = containerWidth / maxPageWidth;
  const clampedZoom = Math.min(Math.max(targetZoom, minZoom), maxZoom);
  return clampedZoom;
};
var createZustandContext = (getStore) => {
  const Context = import_react5.default.createContext(null);
  const Provider = (props) => {
    const [store] = import_react5.default.useState(() => getStore(props.initialValue));
    return (0, import_jsx_runtime2.jsx)(Context.Provider, { value: store, children: props.children });
  };
  return {
    useContext: () => import_react5.default.useContext(Context),
    Context,
    Provider
  };
};
var PDFStore = createZustandContext(
  (initialState) => {
    return createStore((set, get) => {
      var _a, _b;
      return {
        pdfDocumentProxy: initialState.pdfDocumentProxy,
        zoom: initialState.zoom,
        isZoomFitWidth: initialState.isZoomFitWidth ?? false,
        zoomOptions: {
          minZoom: ((_a = initialState.zoomOptions) == null ? void 0 : _a.minZoom) ?? 0.5,
          maxZoom: ((_b = initialState.zoomOptions) == null ? void 0 : _b.maxZoom) ?? 10
        },
        viewportRef: (0, import_react5.createRef)(),
        viewports: initialState.viewports,
        updateZoom: (zoom, isZoomFitWidth = false) => {
          const { minZoom, maxZoom } = get().zoomOptions;
          set((state) => {
            if (typeof zoom === "function") {
              const newZoom2 = clamp2(zoom(state.zoom), minZoom, maxZoom);
              return { zoom: newZoom2, isZoomFitWidth };
            }
            const newZoom = clamp2(zoom, minZoom, maxZoom);
            return { zoom: newZoom, isZoomFitWidth };
          });
        },
        zoomFitWidth: () => {
          const { viewportRef, zoomOptions, viewports } = get();
          if (!viewportRef.current) return;
          const clampedZoom = getFitWidthZoom(
            viewportRef.current.clientWidth,
            viewports,
            zoomOptions
          );
          set({
            zoom: clampedZoom,
            isZoomFitWidth: true
          });
          return clampedZoom;
        },
        currentPage: 1,
        setCurrentPage: (val) => {
          set({
            currentPage: val
          });
        },
        isPinching: false,
        setIsPinching: (val) => {
          set({
            isPinching: val
          });
        },
        virtualizer: null,
        setVirtualizer: (val) => {
          set({
            virtualizer: val
          });
        },
        pageProxies: initialState.pageProxies,
        getPdfPageProxy: (pageNumber) => {
          const proxy = get().pageProxies[pageNumber - 1];
          if (!proxy) throw new Error(`Page ${pageNumber} does not exist`);
          return proxy;
        },
        textContent: [],
        setTextContent: (val) => {
          set({
            textContent: val
          });
        },
        highlights: [],
        setHighlight: (val) => {
          set({
            highlights: val
          });
        },
        customSelectionRects: [],
        setCustomSelectionRects: (val) => {
          set({
            customSelectionRects: val
          });
        },
        coloredHighlights: [],
        addColoredHighlight: (value) => set((prevState) => ({
          coloredHighlights: [...prevState.coloredHighlights, value]
        })),
        deleteColoredHighlight: (uuid) => set((prevState) => ({
          coloredHighlights: prevState.coloredHighlights.filter(
            (rect) => rect.uuid !== uuid
          )
        }))
      };
    });
  }
);
var usePdf = (selector) => useStore(PDFStore.useContext(), selector);
var useAnnotationTooltip = ({
  annotation,
  onOpenChange,
  position = "top",
  isOpen: controlledIsOpen
}) => {
  const isNewAnnotation = Date.now() - new Date(annotation.createdAt).getTime() < 1e3;
  const [isPositionCalculated, setIsPositionCalculated] = (0, import_react5.useState)(false);
  const [isOpen, setIsOpen] = (0, import_react5.useState)(false);
  const viewportRef = usePdf((state) => state.viewportRef);
  const scale = usePdf((state) => state.zoom);
  const effectiveIsOpen = (isOpen && isPositionCalculated || controlledIsOpen) ?? false;
  const { refs, floatingStyles, context } = useFloating2({
    placement: position,
    open: effectiveIsOpen,
    onOpenChange: (open) => {
      setIsOpen(open);
      onOpenChange == null ? void 0 : onOpenChange(open);
    },
    whileElementsMounted: autoUpdate,
    middleware: [
      inline3(),
      offset3(10),
      flip3({
        crossAxis: false,
        fallbackAxisSideDirection: "end"
      }),
      shift3({ padding: 8 })
    ]
  });
  const dismiss = useDismiss(context);
  const { getReferenceProps, getFloatingProps } = useInteractions([dismiss]);
  const updateTooltipPosition = (0, import_react5.useCallback)(() => {
    if (!annotation.highlights.length) {
      setIsPositionCalculated(false);
      return;
    }
    const highlightRects = annotation.highlights;
    let minLeft = Infinity;
    let maxRight = -Infinity;
    let minTop = Infinity;
    let maxBottom = -Infinity;
    const viewportElement = viewportRef.current;
    if (!viewportElement) {
      setIsPositionCalculated(false);
      return;
    }
    const pageElement = viewportElement.querySelector(
      `[data-page-number="${annotation.pageNumber}"]`
    );
    if (!pageElement) {
      setIsPositionCalculated(false);
      return;
    }
    refs.setReference({
      getBoundingClientRect() {
        const pageRect = pageElement.getBoundingClientRect();
        highlightRects.forEach((highlight) => {
          const scaledLeft = highlight.left * scale;
          const scaledWidth = highlight.width * scale;
          const scaledTop = highlight.top * scale;
          const scaledHeight = highlight.height * scale;
          const left = pageRect.left + scaledLeft;
          const right = left + scaledWidth;
          const top = pageRect.top + scaledTop;
          const bottom = top + scaledHeight;
          minLeft = Math.min(minLeft, left);
          maxRight = Math.max(maxRight, right);
          minTop = Math.min(minTop, top);
          maxBottom = Math.max(maxBottom, bottom);
        });
        const width = maxRight - minLeft;
        const height = maxBottom - minTop;
        const centerX = minLeft + width / 2;
        const centerY = minTop + height / 2;
        const rect = {
          width,
          height,
          x: centerX - width / 2,
          y: centerY - height / 2,
          top: centerY - height / 2,
          right: centerX + width / 2,
          bottom: centerY + height / 2,
          left: centerX - width / 2
        };
        return rect;
      },
      getClientRects() {
        return [this.getBoundingClientRect()];
      },
      contextElement: viewportRef.current || void 0
    });
    setIsPositionCalculated(true);
    if (isNewAnnotation) {
      setIsOpen(true);
    }
  }, [
    annotation.highlights,
    annotation.pageNumber,
    refs,
    viewportRef,
    scale,
    isNewAnnotation
  ]);
  (0, import_react5.useEffect)(() => {
    const viewport = viewportRef.current;
    setIsPositionCalculated(false);
    requestAnimationFrame(() => {
      updateTooltipPosition();
    });
    const handleScroll = () => {
      requestAnimationFrame(updateTooltipPosition);
    };
    const handleResize = () => {
      requestAnimationFrame(updateTooltipPosition);
    };
    if (viewport) {
      viewport.addEventListener("scroll", handleScroll, {
        passive: true
      });
    }
    window.addEventListener("resize", handleResize, { passive: true });
    return () => {
      if (viewport) {
        viewport.removeEventListener("scroll", handleScroll);
      }
      window.removeEventListener("resize", handleResize);
    };
  }, [updateTooltipPosition, viewportRef]);
  return {
    isOpen: effectiveIsOpen,
    setIsOpen,
    refs,
    floatingStyles,
    getFloatingProps,
    getReferenceProps
  };
};
var AnnotationTooltip = ({
  annotation,
  children,
  renderTooltipContent,
  hoverTooltipContent,
  onOpenChange,
  className,
  focusedOpenId,
  focusedHoverOpenId,
  hoverClassName,
  isOpen: controlledIsOpen,
  hoverIsOpen: controlledHoverIsOpen
}) => {
  const viewportRef = usePdf((state) => state.viewportRef);
  const closeTimeoutRef = (0, import_react5.useRef)(null);
  const isMouseInTooltipRef = (0, import_react5.useRef)(false);
  const [triggeredPosition, setTriggeredPosition] = (0, import_react5.useState)();
  const {
    isOpen: uncontrolledIsOpen,
    setIsOpen,
    refs,
    floatingStyles,
    getFloatingProps,
    getReferenceProps
  } = useAnnotationTooltip({
    annotation,
    onOpenChange,
    position: triggeredPosition,
    isOpen: controlledIsOpen
  });
  const {
    isOpen: uncontrolledHoverIsOpen,
    setIsOpen: setHoverIsOpen,
    refs: hoverRefs,
    floatingStyles: hoverFloatingStyles,
    getFloatingProps: getHoverFloatingProps,
    getReferenceProps: getHoverReferenceProps
  } = useAnnotationTooltip({
    position: "bottom",
    annotation,
    isOpen: controlledHoverIsOpen
  });
  const isOpen = controlledIsOpen ?? uncontrolledIsOpen;
  const hoverIsOpen = controlledHoverIsOpen || uncontrolledHoverIsOpen;
  const handleClick = (0, import_react5.useCallback)(() => {
    if (controlledIsOpen === void 0) {
      setIsOpen(!isOpen);
    }
  }, [controlledIsOpen, isOpen, setIsOpen]);
  const handleMouseEnter = (0, import_react5.useCallback)(() => {
    if (focusedOpenId && focusedOpenId !== annotation.id) return;
    if (focusedHoverOpenId && focusedHoverOpenId !== annotation.id) return;
    if (hoverTooltipContent) {
      if (closeTimeoutRef.current) {
        clearTimeout(closeTimeoutRef.current);
        closeTimeoutRef.current = null;
      }
      setHoverIsOpen(true);
    }
  }, [
    hoverTooltipContent,
    setHoverIsOpen,
    annotation.id,
    focusedHoverOpenId,
    focusedOpenId
  ]);
  const closeTooltip = (0, import_react5.useCallback)(() => {
    if (!isMouseInTooltipRef.current) {
      setHoverIsOpen(false);
    }
  }, [setHoverIsOpen]);
  const handleMouseLeave = (0, import_react5.useCallback)(() => {
    if (!hoverTooltipContent) return;
    closeTimeoutRef.current = setTimeout(closeTooltip, 100);
  }, [hoverTooltipContent, closeTooltip]);
  const handleTooltipMouseEnter = (0, import_react5.useCallback)(() => {
    if (focusedOpenId && focusedOpenId !== annotation.id) return;
    if (focusedHoverOpenId && focusedHoverOpenId !== annotation.id) return;
    isMouseInTooltipRef.current = true;
    if (closeTimeoutRef.current) {
      clearTimeout(closeTimeoutRef.current);
      closeTimeoutRef.current = null;
    }
  }, [annotation.id, focusedOpenId, focusedHoverOpenId]);
  const handleTooltipMouseLeave = (0, import_react5.useCallback)(() => {
    isMouseInTooltipRef.current = false;
    setHoverIsOpen(false);
  }, [setHoverIsOpen]);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(
      "div",
      {
        ref: (node) => {
          refs.setReference(node);
          hoverRefs.setReference(node);
        },
        onClick: handleClick,
        onMouseEnter: handleMouseEnter,
        onMouseLeave: handleMouseLeave,
        ...getReferenceProps(),
        ...getHoverReferenceProps(),
        children
      }
    ),
    isOpen && viewportRef.current && (0, import_react_dom4.createPortal)(
      (0, import_jsx_runtime2.jsx)(
        "div",
        {
          ref: refs.setFloating,
          className,
          "data-annotation-tooltip": "click",
          style: {
            ...floatingStyles,
            position: "absolute",
            pointerEvents: "auto",
            zIndex: 50
          },
          ...getFloatingProps(),
          children: renderTooltipContent({
            annotation,
            onClose: () => setIsOpen(false),
            setPosition: (position) => setTriggeredPosition(position)
          })
        }
      ),
      viewportRef.current
    ),
    !isOpen && hoverIsOpen && annotation.comment && hoverTooltipContent && viewportRef.current && (0, import_react_dom4.createPortal)(
      (0, import_jsx_runtime2.jsx)(
        "div",
        {
          ref: hoverRefs.setFloating,
          className: hoverClassName,
          "data-annotation-tooltip": "hover",
          style: {
            ...hoverFloatingStyles,
            position: "absolute",
            pointerEvents: "auto",
            zIndex: 51
          },
          onMouseEnter: handleTooltipMouseEnter,
          onMouseLeave: handleTooltipMouseLeave,
          ...getHoverFloatingProps(),
          children: hoverTooltipContent
        }
      ),
      viewportRef.current
    )
  ] });
};
var useAnnotations = create((set) => ({
  annotations: [],
  addAnnotation: (annotation) => set((state) => ({
    annotations: [...state.annotations, annotation]
  })),
  updateAnnotation: (id, updates) => set((state) => ({
    annotations: state.annotations.map(
      (annotation) => annotation.id === id ? {
        ...annotation,
        ...updates
      } : annotation
    )
  })),
  deleteAnnotation: (id) => set((state) => ({
    annotations: state.annotations.filter(
      (annotation) => annotation.id !== id
    )
  })),
  setAnnotations: (annotations) => set({ annotations })
}));
var PDFPageNumberContext = (0, import_react5.createContext)(0);
var usePDFPageNumber = () => {
  return (0, import_react5.useContext)(PDFPageNumberContext);
};
var AnnotationHighlightLayer = ({
  className,
  style,
  renderTooltipContent,
  renderHoverTooltipContent,
  tooltipClassName,
  highlightClassName,
  underlineClassName,
  commentIconPosition,
  commmentIcon,
  commentIconClassName,
  focusedAnnotationId,
  focusedHoverAnnotationId,
  onAnnotationClick,
  onAnnotationTooltipClose,
  hoverTooltipClassName
}) => {
  const { annotations } = useAnnotations();
  const pageNumber = usePDFPageNumber();
  const pageAnnotations = annotations.filter(
    (annotation) => annotation.pageNumber === pageNumber
  );
  const getCommentIconPosition = (highlights) => {
    if (!highlights.length) return { top: 0, right: 10 };
    const sortedHighlights = [...highlights].sort((a2, b) => {
      const topDiff = a2.top - b.top;
      return Math.abs(topDiff) < 3 ? a2.left - b.left : topDiff;
    });
    const lines = [];
    let currentLine = [];
    sortedHighlights.forEach((highlight) => {
      if (currentLine.length === 0) {
        currentLine.push(highlight);
      } else {
        const firstInLine = currentLine[0];
        if (Math.abs(highlight.top - firstInLine.top) <= 3) {
          currentLine.push(highlight);
        } else {
          lines.push([...currentLine]);
          currentLine = [highlight];
        }
      }
    });
    if (currentLine.length > 0) {
      lines.push(currentLine);
    }
    const PAGE_WIDTH = 600;
    const hasLongLine = lines.some((line) => {
      if (line.length === 0) return false;
      const rightmost2 = Math.max(...line.map((h) => h.left + h.width));
      return rightmost2 > PAGE_WIDTH * 0.8;
    });
    const firstHighlight = highlights[0];
    const firstLine = lines[0] || [];
    const leftmost = Math.min(...firstLine.map((h) => h.left));
    const rightmost = Math.max(...firstLine.map((h) => h.left + h.width));
    const lineCenter = leftmost + (rightmost - leftmost) / 2;
    const shouldPositionRight = hasLongLine || lineCenter > PAGE_WIDTH * 0.5;
    const rightPosition = commentIconPosition === "highlight" ? { left: rightmost + 8 } : { right: 10 };
    const leftPosition = commentIconPosition === "highlight" ? { left: leftmost - 18 } : { left: 20 };
    return {
      top: firstHighlight.top + firstHighlight.height / 2 - 6,
      ...shouldPositionRight ? rightPosition : leftPosition
    };
  };
  return (0, import_jsx_runtime2.jsx)("div", { className, style, children: pageAnnotations.map((annotation) => {
    var _a;
    return (0, import_jsx_runtime2.jsx)(
      AnnotationTooltip,
      {
        annotation,
        className: tooltipClassName,
        hoverClassName: hoverTooltipClassName,
        focusedOpenId: focusedAnnotationId,
        focusedHoverOpenId: focusedHoverAnnotationId,
        isOpen: focusedAnnotationId === annotation.id,
        hoverIsOpen: focusedHoverAnnotationId === annotation.id,
        onOpenChange: (open) => {
          if (open && onAnnotationClick) {
            onAnnotationClick(annotation);
          } else if (!open && onAnnotationTooltipClose) {
            onAnnotationTooltipClose(annotation);
          }
        },
        renderTooltipContent,
        hoverTooltipContent: renderHoverTooltipContent({
          annotation,
          onClose: () => {
          }
        }),
        children: (0, import_jsx_runtime2.jsxs)(
          "div",
          {
            style: { cursor: "pointer" },
            onClick: () => onAnnotationClick == null ? void 0 : onAnnotationClick(annotation),
            children: [
              annotation.highlights.map((highlight, index3) => (0, import_jsx_runtime2.jsx)(
                "div",
                {
                  className: highlightClassName,
                  style: {
                    position: "absolute",
                    top: highlight.top,
                    left: highlight.left,
                    width: highlight.width,
                    height: highlight.height,
                    backgroundColor: annotation.color
                  },
                  "data-highlight-id": annotation.id
                },
                `highlight-${// biome-ignore lint/suspicious/noArrayIndexKey: <index>
                index3}`
              )),
              annotation.comment && ((_a = annotation.underlines) == null ? void 0 : _a.map((rect, index3) => (0, import_jsx_runtime2.jsx)(
                "div",
                {
                  className: underlineClassName,
                  style: {
                    position: "absolute",
                    top: rect.top,
                    left: rect.left,
                    width: rect.width,
                    height: 1.1,
                    backgroundColor: annotation.borderColor
                  },
                  "data-comment-id": annotation.id
                },
                `underline-${// biome-ignore lint/suspicious/noArrayIndexKey: <index>
                index3}`
              ))),
              annotation.comment && commmentIcon && (0, import_jsx_runtime2.jsx)(
                "div",
                {
                  className: commentIconClassName,
                  style: {
                    position: "absolute",
                    ...getCommentIconPosition(annotation.highlights),
                    color: "gray",
                    cursor: "pointer",
                    zIndex: 10
                  },
                  "data-comment-icon-id": annotation.id,
                  children: commmentIcon
                }
              )
            ]
          }
        )
      },
      annotation.id
    );
  }) });
};
function r2(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o = e2.length;
    for (t2 = 0; t2 < o; t2++) e2[t2] && (f2 = r2(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e2 = arguments[f2]) && (t2 = r2(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var clsx_default = clsx;
var cancellable = (promise) => {
  let isCancelled = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then(
      (value) => {
        if (!isCancelled) {
          resolve(value);
        }
      },
      (error2) => {
        if (!isCancelled) {
          reject(error2);
        }
      }
    );
  });
  return {
    promise: wrappedPromise,
    cancel() {
      isCancelled = true;
    }
  };
};
var usePdfJump = () => {
  const virtualizer = usePdf((state) => state.virtualizer);
  const setHighlight = usePdf((state) => state.setHighlight);
  const jumpToPage = (0, import_react5.useCallback)(
    (pageIndex, options) => {
      if (!virtualizer) return;
      const defaultOptions = {
        align: "start",
        behavior: "smooth"
      };
      const finalOptions = { ...defaultOptions, ...options };
      virtualizer.scrollToIndex(pageIndex - 1, finalOptions);
    },
    [virtualizer]
  );
  const jumpToOffset = (0, import_react5.useCallback)(
    (offset32) => {
      if (!virtualizer) return;
      virtualizer.scrollToOffset(offset32, {
        align: "start",
        behavior: "smooth"
      });
    },
    [virtualizer]
  );
  const scrollToHighlightRects = (0, import_react5.useCallback)(
    (rects, type, align = "start", additionalOffset = 0) => {
      var _a;
      if (!virtualizer) return;
      const firstPage = Math.min(...rects.map((rect) => rect.pageNumber));
      const pageOffset = virtualizer.getOffsetForIndex(firstPage - 1, "start");
      if (pageOffset === null) return;
      const targetRect = rects.find((rect) => rect.pageNumber === firstPage);
      if (!targetRect) return;
      const isNumber = (pageOffset == null ? void 0 : pageOffset[0]) != null;
      if (!isNumber) return;
      const pageStart = pageOffset[0] ?? 0;
      let rectTop;
      let rectHeight;
      if (type === "percent") {
        const estimatePageHeight = virtualizer.options.estimateSize(
          firstPage - 1
        );
        rectTop = targetRect.top / 100 * estimatePageHeight;
        rectHeight = targetRect.height / 100 * estimatePageHeight;
      } else {
        rectTop = targetRect.top;
        rectHeight = targetRect.height;
      }
      let scrollOffset;
      if (align === "center") {
        const viewportHeight = ((_a = virtualizer.scrollElement) == null ? void 0 : _a.clientHeight) || 0;
        const rectCenter = pageStart + rectTop + rectHeight / 2;
        scrollOffset = rectCenter - viewportHeight / 2;
      } else {
        scrollOffset = pageStart + rectTop;
      }
      scrollOffset += additionalOffset;
      const adjustedOffset = Math.max(0, scrollOffset);
      virtualizer.scrollToOffset(adjustedOffset, {
        align: "start",
        // Always use start when we've calculated our own centering
        behavior: "smooth"
      });
    },
    [virtualizer]
  );
  const jumpToHighlightRects = (0, import_react5.useCallback)(
    (rects, type, align = "start", additionalOffset = 0) => {
      if (!virtualizer) return;
      setHighlight(rects);
      scrollToHighlightRects(rects, type, align, additionalOffset);
    },
    [virtualizer, setHighlight, scrollToHighlightRects]
  );
  return {
    jumpToPage,
    jumpToOffset,
    jumpToHighlightRects,
    scrollToHighlightRects
  };
};
var LinkService = class {
  constructor() {
    __publicField(this, "_pdfDocumentProxy");
    __publicField(this, "externalLinkEnabled", true);
    __publicField(this, "isInPresentationMode", false);
    __publicField(this, "_currentPageNumber", 0);
    __publicField(this, "_pageNavigationCallback");
  }
  get pdfDocumentProxy() {
    if (!this._pdfDocumentProxy) {
      throw new Error("pdfDocumentProxy is not set");
    }
    return this._pdfDocumentProxy;
  }
  get pagesCount() {
    var _a;
    return ((_a = this._pdfDocumentProxy) == null ? void 0 : _a.numPages) || 0;
  }
  get page() {
    return this._currentPageNumber;
  }
  set page(value) {
    this._currentPageNumber = value;
    if (this._pageNavigationCallback) {
      this._pageNavigationCallback(value);
    }
  }
  // Required for link annotations to work
  setDocument(pdfDocument) {
    this._pdfDocumentProxy = pdfDocument;
  }
  setViewer() {
  }
  getDestinationHash(dest) {
    if (!dest) return "";
    const destRef = dest[0];
    if (dest.length > 1 && typeof dest[1] === "object" && dest[1] !== null && "url" in dest[1]) {
      const urlDest = dest[1];
      return urlDest.url;
    }
    if (destRef && typeof destRef === "object") {
      if ("num" in destRef) {
        const numRef = destRef;
        return `#page=${numRef.num + 1}`;
      }
      if ("gen" in destRef) {
        const genRef = destRef;
        const refNum = genRef.num ?? 0;
        return `#page=${refNum + 1}`;
      }
    }
    if (typeof destRef === "number") {
      return `#page=${destRef + 1}`;
    }
    return `#dest-${String(dest)}`;
  }
  getAnchorUrl(hash) {
    if (hash.startsWith("http://") || hash.startsWith("https://")) {
      return hash;
    }
    return `#${hash}`;
  }
  addLinkAttributes(link, url, newWindow) {
    if (!link) return;
    const isExternalLink = url.startsWith("http://") || url.startsWith("https://");
    if (isExternalLink && this.externalLinkEnabled) {
      link.href = url;
      link.target = newWindow === false ? "" : "_blank";
      link.rel = "noopener noreferrer";
    } else if (!isExternalLink) {
      link.href = url;
      link.target = "";
    } else {
      link.href = "#";
      link.target = "";
    }
  }
  async goToDestination(dest) {
    let explicitDest;
    if (typeof dest === "string") {
      explicitDest = await this.pdfDocumentProxy.getDestination(dest);
    } else if (Array.isArray(dest)) {
      explicitDest = dest;
    } else {
      explicitDest = await dest;
    }
    if (!explicitDest) {
      return;
    }
    if (explicitDest.length > 1 && typeof explicitDest[1] === "object" && explicitDest[1] !== null && "url" in explicitDest[1]) {
      return;
    }
    const destRef = explicitDest[0];
    let pageIndex;
    if (destRef && typeof destRef === "object") {
      if ("num" in destRef) {
        try {
          const refProxy = destRef;
          pageIndex = await this.pdfDocumentProxy.getPageIndex(refProxy);
        } catch (_error) {
          return;
        }
      } else {
        return;
      }
    } else if (typeof destRef === "number") {
      pageIndex = destRef;
    } else {
      return;
    }
    const pageNumber = pageIndex + 1;
    if (this._pageNavigationCallback) {
      this._pageNavigationCallback(pageNumber);
    }
  }
  executeNamedAction() {
  }
  navigateTo(dest) {
    this.goToDestination(dest);
  }
  get rotation() {
    return 0;
  }
  set rotation(_value) {
  }
  goToPage(_page_valuer) {
  }
  setHash(hash) {
    if (hash.startsWith("#page=")) {
      const pageNumber = parseInt(hash.substring(6), 10);
      if (!Number.isNaN(pageNumber)) {
        this.goToPage(pageNumber);
      }
    }
  }
  executeSetOCGState() {
  }
  // Method to register navigation callback
  registerPageNavigationCallback(callback) {
    this._pageNavigationCallback = callback;
  }
  // Method to unregister navigation callback
  unregisterPageNavigationCallback() {
    this._pageNavigationCallback = void 0;
  }
};
var defaultLinkService = new LinkService();
var PDFLinkServiceContext = (0, import_react5.createContext)(defaultLinkService);
var usePDFLinkService = () => {
  return (0, import_react5.useContext)(PDFLinkServiceContext);
};
var useVisibility = ({
  elementRef
}) => {
  const [visible, setVisible] = (0, import_react5.useState)(false);
  (0, import_react5.useEffect)(() => {
    if (!elementRef.current) {
      return;
    }
    const observer = new IntersectionObserver(([entry]) => {
      setVisible((entry == null ? void 0 : entry.isIntersecting) ?? false);
    });
    observer.observe(elementRef.current);
    return () => {
      observer.disconnect();
    };
  }, [elementRef]);
  return { visible };
};
var defaultAnnotationLayerParams = {
  renderForms: true,
  externalLinksEnabled: true,
  jumpOptions: { behavior: "smooth", align: "start" }
};
var useAnnotationLayer = (params) => {
  const mergedParams = (0, import_react5.useMemo)(() => {
    return { ...defaultAnnotationLayerParams, ...params };
  }, [params]);
  const annotationLayerRef = (0, import_react5.useRef)(null);
  const annotationLayerObjectRef = (0, import_react5.useRef)(null);
  const linkService = usePDFLinkService();
  const { visible } = useVisibility({
    elementRef: annotationLayerRef
  });
  const pageNumber = usePDFPageNumber();
  const pdfPageProxy = usePdf((state) => state.getPdfPageProxy(pageNumber));
  const pdfDocumentProxy = usePdf((state) => state.pdfDocumentProxy);
  (0, import_react5.useEffect)(() => {
    linkService.externalLinkEnabled = mergedParams.externalLinksEnabled;
  }, [linkService, mergedParams.externalLinksEnabled]);
  const { jumpToPage } = usePdfJump();
  (0, import_react5.useEffect)(() => {
    if (!jumpToPage) return;
    const handlePageNavigation = (pageNumber2) => {
      jumpToPage(pageNumber2, mergedParams.jumpOptions);
    };
    linkService.registerPageNavigationCallback(handlePageNavigation);
    return () => {
      linkService.unregisterPageNavigationCallback();
    };
  }, [jumpToPage, linkService, mergedParams.jumpOptions]);
  (0, import_react5.useEffect)(() => {
    const style = document.createElement("style");
    style.textContent = `
      .annotationLayer {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        opacity: 1;
        z-index: 3;
      }
      
      .annotationLayer section {
        position: absolute;
      }
      
      .annotationLayer .linkAnnotation > a,
      .annotationLayer .buttonWidgetAnnotation.pushButton > a {
        position: absolute;
        font-size: 1em;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: url("data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7") 0 0 repeat;
        cursor: pointer;
      }
      
      .annotationLayer .linkAnnotation > a:hover,
      .annotationLayer .buttonWidgetAnnotation.pushButton > a:hover {
        opacity: 0.2;
        background: rgba(255, 255, 0, 1);
        box-shadow: 0 2px 10px rgba(255, 255, 0, 1);
      }
    `;
    document.head.appendChild(style);
    return () => {
      document.head.removeChild(style);
    };
  }, []);
  (0, import_react5.useEffect)(() => {
    if (!annotationLayerRef.current) return;
    const element = annotationLayerRef.current;
    const handleLinkClick = (e2) => {
      if (!e2.target || !(e2.target instanceof HTMLAnchorElement)) return;
      const target = e2.target;
      const href = target.getAttribute("href") || "";
      if (href.startsWith("#page=")) {
        e2.preventDefault();
        const pageNumber2 = parseInt(href.substring(6), 10);
        if (!Number.isNaN(pageNumber2)) {
          linkService.goToPage(pageNumber2);
        }
      }
    };
    element.addEventListener("click", handleLinkClick);
    return () => {
      element.removeEventListener("click", handleLinkClick);
    };
  }, [linkService]);
  (0, import_react5.useEffect)(() => {
    if (!annotationLayerRef.current) {
      return;
    }
    if (visible) {
      annotationLayerRef.current.style.contentVisibility = "visible";
    } else {
      annotationLayerRef.current.style.contentVisibility = "hidden";
    }
  }, [visible]);
  (0, import_react5.useEffect)(() => {
    if (!annotationLayerRef.current || !pdfPageProxy || !pdfDocumentProxy) {
      return;
    }
    if (linkService._pdfDocumentProxy !== pdfDocumentProxy) {
      linkService.setDocument(pdfDocumentProxy);
    }
    annotationLayerRef.current.innerHTML = "";
    annotationLayerRef.current.className = "annotationLayer";
    const viewport = pdfPageProxy.getViewport({ scale: 1 });
    const annotationLayerConfig = {
      div: annotationLayerRef.current,
      viewport,
      page: pdfPageProxy,
      linkService,
      accessibilityManager: void 0,
      annotationCanvasMap: void 0,
      annotationEditorUIManager: void 0,
      structTreeLayer: void 0
    };
    const annotationLayer = new __webpack_exports__AnnotationLayer(annotationLayerConfig);
    annotationLayerObjectRef.current = annotationLayer;
    const { cancel } = cancellable(
      (async () => {
        try {
          const annotations = await pdfPageProxy.getAnnotations();
          await annotationLayer.render({
            ...annotationLayerConfig,
            ...mergedParams,
            annotations,
            linkService
          });
        } catch (_error) {
        }
      })()
    );
    return () => {
      cancel();
    };
  }, [pdfPageProxy, pdfDocumentProxy, mergedParams, linkService]);
  return {
    annotationLayerRef
  };
};
var AnnotationLayer2 = ({
  renderForms = true,
  externalLinksEnabled = true,
  jumpOptions = { behavior: "smooth", align: "start" },
  className,
  style,
  ...props
}) => {
  const { annotationLayerRef } = useAnnotationLayer({
    renderForms,
    externalLinksEnabled,
    jumpOptions
  });
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: clsx_default("annotationLayer", className),
      style: {
        ...style,
        position: "absolute",
        top: 0,
        left: 0
      },
      ...props,
      ref: annotationLayerRef
    }
  );
};
var useDpr = () => {
  const [dpr, setDPR] = (0, import_react5.useState)(
    !window ? 1 : Math.min(window.devicePixelRatio, 2)
  );
  (0, import_react5.useEffect)(() => {
    if (!window) {
      return;
    }
    const handleDPRChange = () => {
      setDPR(window.devicePixelRatio);
    };
    const windowMatch = window.matchMedia(
      `screen and (min-resolution: ${dpr}dppx)`
    );
    windowMatch.addEventListener("change", handleDPRChange);
    return () => {
      windowMatch.removeEventListener("change", handleDPRChange);
    };
  }, [dpr]);
  return dpr;
};
var MAX_CANVAS_PIXELS = 16777216;
var MAX_CANVAS_DIMENSION = 32767;
var useCanvasLayer = ({ background }) => {
  const canvasRef = (0, import_react5.useRef)(null);
  const pageNumber = usePDFPageNumber();
  const dpr = useDpr();
  const bouncyZoom = usePdf((state) => state.zoom);
  const pdfPageProxy = usePdf((state) => state.getPdfPageProxy(pageNumber));
  const [zoom] = a(bouncyZoom, 100);
  const clampScaleForPage = (0, import_react5.useCallback)(
    (targetScale, pageWidth, pageHeight) => {
      if (!targetScale) {
        return 0;
      }
      const areaLimit = Math.sqrt(
        MAX_CANVAS_PIXELS / Math.max(pageWidth * pageHeight, 1)
      );
      const widthLimit = MAX_CANVAS_DIMENSION / Math.max(pageWidth, 1);
      const heightLimit = MAX_CANVAS_DIMENSION / Math.max(pageHeight, 1);
      const safeScale = Math.min(
        targetScale,
        Number.isFinite(areaLimit) ? areaLimit : targetScale,
        Number.isFinite(widthLimit) ? widthLimit : targetScale,
        Number.isFinite(heightLimit) ? heightLimit : targetScale
      );
      return Math.max(safeScale, 0);
    },
    []
  );
  (0, import_react5.useLayoutEffect)(() => {
    if (!canvasRef.current) {
      return;
    }
    const baseCanvas = canvasRef.current;
    const baseViewport = pdfPageProxy.getViewport({ scale: 1 });
    const pageWidth = baseViewport.width;
    const pageHeight = baseViewport.height;
    const targetBaseScale = dpr * Math.min(zoom, 1);
    const baseScale = clampScaleForPage(targetBaseScale, pageWidth, pageHeight);
    baseCanvas.width = Math.floor(pageWidth * baseScale);
    baseCanvas.height = Math.floor(pageHeight * baseScale);
    baseCanvas.style.position = "absolute";
    baseCanvas.style.top = "0";
    baseCanvas.style.left = "0";
    baseCanvas.style.width = `${pageWidth}px`;
    baseCanvas.style.height = `${pageHeight}px`;
    baseCanvas.style.transform = "translate(0px, 0px)";
    baseCanvas.style.zIndex = "0";
    baseCanvas.style.pointerEvents = "none";
    const context = baseCanvas.getContext("2d");
    if (!context) {
      return;
    }
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
    const viewport = pdfPageProxy.getViewport({ scale: baseScale });
    const renderingTask = pdfPageProxy.render({
      canvasContext: context,
      viewport,
      background
    });
    renderingTask.promise.catch((error2) => {
      if (error2.name === "RenderingCancelledException") {
        return;
      }
      throw error2;
    });
    return () => {
      void renderingTask.cancel();
    };
  }, [pdfPageProxy, background, dpr, zoom, clampScaleForPage]);
  return {
    canvasRef
  };
};
var MAX_CANVAS_PIXELS2 = 16777216;
var MAX_CANVAS_DIMENSION2 = 32767;
var useDetailCanvasLayer = ({
  background,
  baseCanvasRef
}) => {
  const containerRef = (0, import_react5.useRef)(null);
  const detailCanvasRef = (0, import_react5.useRef)(null);
  const pageNumber = usePDFPageNumber();
  const dpr = useDpr();
  const bouncyZoom = usePdf((state) => state.zoom);
  const pdfPageProxy = usePdf((state) => state.getPdfPageProxy(pageNumber));
  const viewportRef = usePdf((state) => state.viewportRef);
  const [zoom] = a(bouncyZoom, 200);
  const [scrollTick, setScrollTick] = (0, import_react5.useState)(0);
  const [debouncedScrollTick] = a(scrollTick, 20);
  const ensureDetailCanvas = (0, import_react5.useCallback)(() => {
    var _a;
    let detailCanvas = detailCanvasRef.current;
    if (!detailCanvas) {
      const parent = (_a = baseCanvasRef.current) == null ? void 0 : _a.parentElement;
      if (!parent) {
        return null;
      }
      detailCanvas = document.createElement("canvas");
      parent.appendChild(detailCanvas);
      detailCanvasRef.current = detailCanvas;
    }
    detailCanvas.style.position = "absolute";
    detailCanvas.style.top = "0";
    detailCanvas.style.left = "0";
    detailCanvas.style.pointerEvents = "none";
    detailCanvas.style.zIndex = "0";
    return detailCanvas;
  }, [baseCanvasRef]);
  const clampScaleForPage = (0, import_react5.useCallback)(
    (targetScale, pageWidth, pageHeight) => {
      if (!targetScale) {
        return 0;
      }
      const areaLimit = Math.sqrt(
        MAX_CANVAS_PIXELS2 / Math.max(pageWidth * pageHeight, 1)
      );
      const widthLimit = MAX_CANVAS_DIMENSION2 / Math.max(pageWidth, 1);
      const heightLimit = MAX_CANVAS_DIMENSION2 / Math.max(pageHeight, 1);
      const safeScale = Math.min(
        targetScale,
        Number.isFinite(areaLimit) ? areaLimit : targetScale,
        Number.isFinite(widthLimit) ? widthLimit : targetScale,
        Number.isFinite(heightLimit) ? heightLimit : targetScale
      );
      return Math.max(safeScale, 0);
    },
    []
  );
  (0, import_react5.useLayoutEffect)(() => {
    const scrollContainer = viewportRef == null ? void 0 : viewportRef.current;
    if (!scrollContainer) return;
    const handleScroll = () => {
      setScrollTick((prev) => prev + 1);
    };
    scrollContainer.addEventListener("scroll", handleScroll, { passive: true });
    return () => {
      scrollContainer.removeEventListener("scroll", handleScroll);
    };
  }, [viewportRef == null ? void 0 : viewportRef.current]);
  (0, import_react5.useLayoutEffect)(() => {
    var _a;
    if (!(viewportRef == null ? void 0 : viewportRef.current)) {
      return;
    }
    const detailCanvas = ensureDetailCanvas();
    const container = containerRef.current;
    if (!detailCanvas || !container) {
      return;
    }
    const scrollContainer = viewportRef.current;
    const pageContainer = ((_a = baseCanvasRef.current) == null ? void 0 : _a.parentElement) ?? null;
    if (!pageContainer) {
      detailCanvas.style.display = "none";
      detailCanvas.width = 0;
      detailCanvas.height = 0;
      return;
    }
    const baseViewport = pdfPageProxy.getViewport({ scale: 1 });
    const pageWidth = baseViewport.width;
    const pageHeight = baseViewport.height;
    const scrollX = scrollContainer.scrollLeft / zoom;
    const scrollY = scrollContainer.scrollTop / zoom;
    const viewportWidth = scrollContainer.clientWidth / zoom;
    const viewportHeight = scrollContainer.clientHeight / zoom;
    const pageRect = pageContainer.getBoundingClientRect();
    const containerRect = scrollContainer.getBoundingClientRect();
    const pageLeft = (pageRect.left - containerRect.left) / zoom + scrollX;
    const pageTop = (pageRect.top - containerRect.top) / zoom + scrollY;
    const visibleLeft = Math.max(0, scrollX - pageLeft);
    const visibleTop = Math.max(0, scrollY - pageTop);
    const visibleRight = Math.min(
      pageWidth,
      scrollX + viewportWidth - pageLeft
    );
    const visibleBottom = Math.min(
      pageHeight,
      scrollY + viewportHeight - pageTop
    );
    const visibleWidth = Math.max(0, visibleRight - visibleLeft);
    const visibleHeight = Math.max(0, visibleBottom - visibleTop);
    const targetDetailScale = dpr * zoom * 1.3;
    const baseTargetScale = dpr * Math.min(zoom, 1);
    const baseScale = clampScaleForPage(baseTargetScale, pageWidth, pageHeight);
    const needsDetail = zoom > 1 && targetDetailScale - baseScale > 1e-3;
    if (!needsDetail || visibleWidth <= 0 || visibleHeight <= 0) {
      detailCanvas.style.display = "none";
      detailCanvas.width = 0;
      detailCanvas.height = 0;
      return;
    }
    detailCanvas.style.display = "block";
    const pdfOffsetX = visibleLeft;
    const pdfOffsetY = visibleTop;
    const pdfWidth = visibleWidth * targetDetailScale;
    const pdfHeight = visibleHeight * targetDetailScale;
    const effectiveScale = targetDetailScale;
    const actualWidth = pdfWidth;
    const actualHeight = pdfHeight;
    detailCanvas.width = actualWidth;
    detailCanvas.height = actualHeight;
    const scaledWidth = visibleWidth * zoom;
    const scaledHeight = visibleHeight * zoom;
    detailCanvas.style.width = `${scaledWidth}px`;
    detailCanvas.style.height = `${scaledHeight}px`;
    detailCanvas.style.transformOrigin = "center center";
    detailCanvas.style.transform = `translate(${visibleLeft * zoom}px, ${visibleTop * zoom}px) `;
    container.style.transform = `scale3d(${1 / zoom}, ${1 / zoom}, 1)`;
    container.style.transformOrigin = `0 0`;
    const context = detailCanvas.getContext("2d");
    if (!context) {
      return;
    }
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.clearRect(0, 0, detailCanvas.width, detailCanvas.height);
    const transform = [
      1,
      0,
      0,
      1,
      -pdfOffsetX * effectiveScale,
      -pdfOffsetY * effectiveScale
    ];
    const detailViewport = pdfPageProxy.getViewport({ scale: effectiveScale });
    const renderingTask = pdfPageProxy.render({
      canvasContext: context,
      viewport: detailViewport,
      background,
      transform
    });
    renderingTask.promise.catch((error2) => {
      if (error2.name === "RenderingCancelledException") {
        return;
      }
      throw error2;
    });
    return () => {
      void renderingTask.cancel();
    };
  }, [
    pdfPageProxy,
    zoom,
    background,
    dpr,
    viewportRef,
    ensureDetailCanvas,
    clampScaleForPage,
    baseCanvasRef,
    debouncedScrollTick
  ]);
  return {
    detailCanvasRef,
    containerRef
  };
};
var CanvasLayer = ({
  style,
  background,
  ...props
}) => {
  const { canvasRef } = useCanvasLayer({ background });
  const { detailCanvasRef, containerRef } = useDetailCanvasLayer({
    background,
    baseCanvasRef: canvasRef
  });
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)("canvas", { ...props, ref: canvasRef, style }),
    (0, import_jsx_runtime2.jsx)(
      "div",
      {
        ref: containerRef,
        className: "absolute top-0 left-0 w-full h-full flex items-center justify-center",
        children: (0, import_jsx_runtime2.jsx)("canvas", { ref: detailCanvasRef })
      }
    )
  ] });
};
var MERGE_THRESHOLD = 2;
var shouldMergeRects = (rect1, rect2) => {
  const verticalOverlap = !(rect1.top > rect2.top + rect2.height || rect2.top > rect1.top + rect1.height);
  const horizontallyConnected = Math.abs(rect1.left + rect1.width - rect2.left) <= MERGE_THRESHOLD || Math.abs(rect2.left + rect2.width - rect1.left) <= MERGE_THRESHOLD || rect1.left < rect2.left + rect2.width && rect2.left < rect1.left + rect1.width;
  return verticalOverlap && horizontallyConnected;
};
var consolidateHighlightRects = (rects) => {
  if (rects.length <= 1) return rects;
  const consolidated = [];
  const sorted = [...rects].sort((a2, b) => {
    const pageCompare = a2.pageNumber - b.pageNumber;
    if (pageCompare !== 0) return pageCompare;
    const topDiff = a2.top - b.top;
    return Math.abs(topDiff) < 2 ? a2.left - b.left : topDiff;
  });
  let current = sorted[0];
  if (!current) return rects;
  for (let i2 = 1; i2 < sorted.length; i2++) {
    const next = sorted[i2];
    if (!next) continue;
    const samePageAndLine = current.pageNumber === next.pageNumber && Math.abs(current.top - next.top) < Math.max(current.height, next.height) * 0.5;
    const horizontallyConnected = samePageAndLine && // Adjacent (touching or very close)
    (Math.abs(current.left + current.width - next.left) <= MERGE_THRESHOLD || Math.abs(next.left + next.width - current.left) <= MERGE_THRESHOLD || // Overlapping
    current.left < next.left + next.width && next.left < current.left + current.width || // Very close (small gap)
    Math.abs(current.left + current.width - next.left) <= current.height * 0.2);
    if (horizontallyConnected) {
      const newLeft = Math.min(current.left, next.left);
      const newRight = Math.max(
        current.left + current.width,
        next.left + next.width
      );
      const newTop = Math.min(current.top, next.top);
      const newBottom = Math.max(
        current.top + current.height,
        next.top + next.height
      );
      current = {
        left: newLeft,
        top: newTop,
        width: newRight - newLeft,
        height: newBottom - newTop,
        pageNumber: current.pageNumber
      };
    } else {
      consolidated.push(current);
      current = next;
    }
  }
  if (current) {
    consolidated.push(current);
  }
  return consolidated;
};
var consolidateRects = (rects) => {
  if (rects.length <= 1) return rects;
  const result = [];
  const visited = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < rects.length; i2++) {
    if (visited.has(i2)) continue;
    const currentRect = rects[i2];
    if (!currentRect) continue;
    const currentGroup = [currentRect];
    visited.add(i2);
    let foundNew = true;
    while (foundNew) {
      foundNew = false;
      for (let j = 0; j < rects.length; j++) {
        if (visited.has(j)) continue;
        const candidateRect = rects[j];
        if (!candidateRect) continue;
        const shouldMergeWithGroup = currentGroup.some(
          (groupRect) => doRectsOverlap(groupRect, candidateRect)
        );
        if (shouldMergeWithGroup) {
          currentGroup.push(candidateRect);
          visited.add(j);
          foundNew = true;
        }
      }
    }
    result.push(mergeRectGroup(currentGroup));
  }
  return result;
};
var doRectsOverlap = (rect1, rect2) => {
  const horizontalOverlap = rect1.left < rect2.left + rect2.width && rect2.left < rect1.left + rect1.width;
  const verticalOverlap = rect1.top < rect2.top + rect2.height && rect2.top < rect1.top + rect1.height;
  const closeEnough = shouldMergeRects(rect1, rect2);
  return horizontalOverlap && verticalOverlap || closeEnough;
};
var mergeRectGroup = (rects) => {
  if (rects.length === 1) {
    const rect = rects[0];
    if (!rect) throw new Error("Invalid rect in group");
    return rect;
  }
  const firstRect = rects[0];
  if (!firstRect) throw new Error("Invalid first rect in group");
  let minLeft = firstRect.left;
  let minTop = firstRect.top;
  let maxRight = firstRect.left + firstRect.width;
  let maxBottom = firstRect.top + firstRect.height;
  rects.forEach((rect) => {
    if (!rect) return;
    minLeft = Math.min(minLeft, rect.left);
    minTop = Math.min(minTop, rect.top);
    maxRight = Math.max(maxRight, rect.left + rect.width);
    maxBottom = Math.max(maxBottom, rect.top + rect.height);
  });
  return {
    left: minLeft,
    top: minTop,
    width: maxRight - minLeft,
    height: maxBottom - minTop,
    pageNumber: firstRect.pageNumber
  };
};
var useSelectionDimensions = () => {
  const store = PDFStore.useContext();
  const getAnnotationDimension = () => {
    const selection = window.getSelection();
    if (!selection || selection.isCollapsed) return;
    const range = selection.getRangeAt(0);
    const highlightRects = [];
    const underlineRects = [];
    const textLayerMapHighlight = /* @__PURE__ */ new Map();
    const textLayerMapUnderline = /* @__PURE__ */ new Map();
    const clientRects = Array.from(range.getClientRects()).filter(
      (rect) => rect.width > 2 && rect.height > 2
    );
    clientRects.forEach((clientRect) => {
      var _a, _b;
      let element = document.elementFromPoint(
        clientRect.left + 1,
        clientRect.top + clientRect.height / 2
      );
      if (!element) {
        element = document.elementFromPoint(
          clientRect.left + clientRect.width / 2,
          clientRect.top + clientRect.height / 2
        );
      }
      if (!element) {
        element = document.elementFromPoint(
          clientRect.right - 1,
          clientRect.top + clientRect.height / 2
        );
      }
      if (!element) {
        element = document.elementFromPoint(
          clientRect.left + clientRect.width / 2,
          clientRect.top + 1
        );
      }
      if (!element) {
        element = document.elementFromPoint(
          clientRect.left + clientRect.width / 2,
          clientRect.bottom - 1
        );
      }
      const textLayer = element == null ? void 0 : element.closest(".textLayer");
      if (!textLayer) return;
      const isSuperOrSubScript = (el) => {
        var _a2, _b2;
        if (!el) return false;
        if (el.tagName.toLowerCase() === "sup" || el.tagName.toLowerCase() === "sub") {
          return true;
        }
        const classes = el.className;
        if (typeof classes === "string") {
          const superSubClasses = ["superscript", "subscript", "sup", "sub"];
          if (superSubClasses.some((c2) => classes.includes(c2))) {
            return true;
          }
        }
        const elementRect = el.getBoundingClientRect();
        if (elementRect.height < 6 && elementRect.width < 15) {
          const textContent = ((_a2 = el.textContent) == null ? void 0 : _a2.trim()) || "";
          if (textContent.length <= 2 && /^[\d\w]{1,2}$/.test(textContent)) {
            const parentRect = (_b2 = el.parentElement) == null ? void 0 : _b2.getBoundingClientRect();
            if (parentRect && parentRect.height > elementRect.height * 2) {
              const elementCenter = elementRect.top + elementRect.height / 2;
              const parentCenter = parentRect.top + parentRect.height / 2;
              const verticalOffset = Math.abs(elementCenter - parentCenter);
              if (verticalOffset > parentRect.height * 0.4) {
                return true;
              }
            }
          }
        }
        return false;
      };
      const pageNumber = parseInt(
        textLayer.getAttribute("data-page-number") || "1",
        10
      );
      const textLayerRect = textLayer.getBoundingClientRect();
      const zoom = store.getState().zoom;
      const highlightRect = {
        width: clientRect.width / zoom,
        height: clientRect.height / zoom,
        top: (clientRect.top - textLayerRect.top) / zoom,
        left: (clientRect.left - textLayerRect.left) / zoom,
        pageNumber
      };
      if (!textLayerMapHighlight.has(pageNumber)) {
        textLayerMapHighlight.set(pageNumber, []);
      }
      (_a = textLayerMapHighlight.get(pageNumber)) == null ? void 0 : _a.push(highlightRect);
      const shouldCreateUnderline = !isSuperOrSubScript(element);
      if (shouldCreateUnderline) {
        const baselineOffset = clientRect.height * 0.85;
        const underlineHeight = 2;
        const underlineRect = {
          width: clientRect.width / zoom,
          height: underlineHeight / zoom,
          top: (clientRect.top - textLayerRect.top + baselineOffset) / zoom,
          left: (clientRect.left - textLayerRect.left) / zoom,
          pageNumber
        };
        if (!textLayerMapUnderline.has(pageNumber)) {
          textLayerMapUnderline.set(pageNumber, []);
        }
        (_b = textLayerMapUnderline.get(pageNumber)) == null ? void 0 : _b.push(underlineRect);
      }
    });
    textLayerMapHighlight.forEach((rects) => {
      if (rects.length > 0) {
        if (rects.length === 1) {
          highlightRects.push(...rects);
        } else {
          const consolidated = consolidateHighlightRects(rects);
          highlightRects.push(...consolidated);
        }
      }
    });
    textLayerMapUnderline.forEach((rects) => {
      if (rects.length > 0) {
        const lineGroups = groupRectsByLine(rects);
        lineGroups.forEach((group) => {
          if (group.length === 0) return;
          group.sort((a2, b) => a2.left - b.left);
          let i2 = 0;
          while (i2 < group.length) {
            const startRect = group[i2];
            if (!startRect) {
              i2++;
              continue;
            }
            let endIndex = i2;
            while (endIndex + 1 < group.length) {
              const currentRect = group[endIndex];
              const nextRect = group[endIndex + 1];
              if (!currentRect || !nextRect) break;
              const gap = nextRect.left - (currentRect.left + currentRect.width);
              const maxGapAllowed = Math.max(
                MERGE_THRESHOLD,
                currentRect.height * 0.3
              );
              if (gap <= maxGapAllowed) {
                endIndex++;
              } else {
                break;
              }
            }
            const endRect = group[endIndex];
            if (!endRect) {
              i2++;
              continue;
            }
            const lineRect = {
              width: endRect.left + endRect.width - startRect.left,
              height: 1.5,
              top: startRect.top,
              left: startRect.left,
              pageNumber: startRect.pageNumber
            };
            underlineRects.push(lineRect);
            i2 = endIndex + 1;
          }
        });
      }
    });
    if (underlineRects.length === 0 && highlightRects.length > 0) {
      highlightRects.forEach((highlightRect) => {
        const baselineOffset = highlightRect.height * 0.85;
        const underlineHeight = 1.5;
        const underlineRect = {
          width: highlightRect.width,
          height: underlineHeight,
          top: highlightRect.top + baselineOffset,
          left: highlightRect.left,
          pageNumber: highlightRect.pageNumber
        };
        underlineRects.push(underlineRect);
      });
    }
    return {
      highlights: highlightRects.sort((a2, b) => a2.pageNumber - b.pageNumber),
      underlines: consolidateUnderlines(underlineRects).sort(
        (a2, b) => a2.pageNumber - b.pageNumber
      ),
      text: range.toString().trim(),
      isCollapsed: false
    };
  };
  const groupRectsByLine = (rects) => {
    const VERTICAL_TOLERANCE = 3;
    const groups = [];
    rects.forEach((rect) => {
      const centerY = rect.top + rect.height / 2;
      let foundGroup = false;
      for (const group of groups) {
        if (group.length === 0) continue;
        const firstRect = group[0];
        if (!firstRect) continue;
        const groupCenterY = firstRect.top + firstRect.height / 2;
        if (Math.abs(centerY - groupCenterY) <= VERTICAL_TOLERANCE) {
          group.push(rect);
          foundGroup = true;
          break;
        }
      }
      if (!foundGroup) {
        groups.push([rect]);
      }
    });
    return groups;
  };
  const consolidateUnderlines = (underlines) => {
    if (underlines.length <= 1) return underlines;
    const consolidated = [];
    const sorted = [...underlines].sort((a2, b) => {
      const pageCompare = a2.pageNumber - b.pageNumber;
      if (pageCompare !== 0) return pageCompare;
      const topCompare = a2.top - b.top;
      return Math.abs(topCompare) < 1 ? a2.left - b.left : topCompare;
    });
    let current = sorted[0];
    for (let i2 = 1; i2 < sorted.length; i2++) {
      const next = sorted[i2];
      const samePageAndLine = current.pageNumber === next.pageNumber && Math.abs(current.top - next.top) < 1;
      const horizontallyConnected = samePageAndLine && (Math.abs(current.left + current.width - next.left) <= MERGE_THRESHOLD || current.left < next.left + next.width && next.left < current.left + current.width);
      if (horizontallyConnected) {
        const newWidth = Math.max(current.left + current.width, next.left + next.width) - Math.min(current.left, next.left);
        current = {
          ...current,
          left: Math.min(current.left, next.left),
          width: newWidth
        };
      } else {
        consolidated.push(current);
        current = next;
      }
    }
    consolidated.push(current);
    return consolidated;
  };
  const getDimension = () => {
    const selection = window.getSelection();
    if (!selection || selection.isCollapsed) return;
    const range = selection.getRangeAt(0);
    const highlights = [];
    const textLayerMap = /* @__PURE__ */ new Map();
    const clientRects = Array.from(range.getClientRects()).filter(
      (rect) => rect.width > 2 && rect.height > 2
    );
    clientRects.forEach((clientRect) => {
      var _a;
      const element = document.elementFromPoint(
        clientRect.left + 1,
        clientRect.top + clientRect.height / 2
      );
      const textLayer = element == null ? void 0 : element.closest(".textLayer");
      if (!textLayer) return;
      const pageNumber = parseInt(
        textLayer.getAttribute("data-page-number") || "1",
        10
      );
      const textLayerRect = textLayer.getBoundingClientRect();
      const zoom = store.getState().zoom;
      const rect = {
        width: clientRect.width / zoom,
        height: clientRect.height / zoom,
        top: (clientRect.top - textLayerRect.top) / zoom,
        left: (clientRect.left - textLayerRect.left) / zoom,
        pageNumber
      };
      if (!textLayerMap.has(pageNumber)) {
        textLayerMap.set(pageNumber, []);
      }
      (_a = textLayerMap.get(pageNumber)) == null ? void 0 : _a.push(rect);
    });
    textLayerMap.forEach((rects) => {
      if (rects.length > 0) {
        const consolidated = consolidateRects(rects);
        highlights.push(...consolidated);
      }
    });
    return {
      highlights: highlights.sort((a2, b) => a2.pageNumber - b.pageNumber),
      text: range.toString().trim(),
      isCollapsed: false
    };
  };
  const getSelection = () => getDimension();
  return { getDimension, getSelection, getAnnotationDimension };
};
var SelectionTooltip = ({ children }) => {
  const [isOpen, setIsOpen] = (0, import_react5.useState)(false);
  const lastSelectionRef = (0, import_react5.useRef)(null);
  const viewportRef = usePdf((state) => state.viewportRef);
  const { refs, floatingStyles, context } = useFloating2({
    placement: "bottom",
    open: isOpen,
    onOpenChange: setIsOpen,
    whileElementsMounted: autoUpdate,
    middleware: [offset3(10), shift3({ padding: 8 })]
  });
  const dismiss = useDismiss(context);
  const { getFloatingProps } = useInteractions([dismiss]);
  const updateTooltipPosition = (0, import_react5.useCallback)(() => {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      setIsOpen(false);
      lastSelectionRef.current = null;
      return;
    }
    const range = selection.getRangeAt(0);
    if (!range) return;
    const rects = range.getClientRects();
    const lastRect = rects[rects.length - 1];
    lastSelectionRef.current = range;
    if (lastRect) {
      refs.setReference({
        getBoundingClientRect: () => ({
          width: lastRect.width,
          height: lastRect.height,
          x: lastRect.left,
          y: lastRect.bottom,
          // Position below the last line of selection
          top: lastRect.bottom,
          right: lastRect.right,
          bottom: lastRect.bottom + lastRect.height,
          left: lastRect.left
        }),
        getClientRects: () => [lastRect]
      });
      setIsOpen(true);
    } else {
      setIsOpen(false);
    }
  }, [refs]);
  (0, import_react5.useEffect)(() => {
    const handleSelectionChange = () => {
      var _a;
      const selection = document.getSelection();
      if (selection && ((_a = viewportRef.current) == null ? void 0 : _a.contains(selection.anchorNode))) {
        const anchorNode = selection.anchorNode;
        const focusNode = selection.focusNode;
        const isInUnselectableArea = (node) => {
          if (!node) return false;
          let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
          while (element) {
            if (element.getAttribute("data-annotation-tooltip")) {
              return true;
            }
            if (element.hasAttribute("data-floating-ui-portal")) {
              return true;
            }
            element = element.parentElement;
          }
          return false;
        };
        if (!isInUnselectableArea(anchorNode) && !isInUnselectableArea(focusNode)) {
          requestAnimationFrame(updateTooltipPosition);
        } else {
          setIsOpen(false);
        }
      } else {
        setIsOpen(false);
      }
    };
    const handleScroll = () => {
      if (!isOpen || !lastSelectionRef.current) return;
      requestAnimationFrame(updateTooltipPosition);
    };
    document.addEventListener("selectionchange", handleSelectionChange);
    if (viewportRef.current) {
      viewportRef.current.addEventListener("scroll", handleScroll, {
        passive: true
      });
    }
    return () => {
      document.removeEventListener("selectionchange", handleSelectionChange);
      if (viewportRef.current) {
        viewportRef.current.removeEventListener("scroll", handleScroll);
      }
    };
  }, [isOpen, viewportRef, updateTooltipPosition]);
  (0, import_react5.useEffect)(() => {
    const handleFloatingClick = (e2) => {
      var _a;
      if ((_a = refs.floating.current) == null ? void 0 : _a.contains(e2.target)) {
        e2.stopPropagation();
      }
    };
    document.addEventListener("click", handleFloatingClick);
    return () => document.removeEventListener("click", handleFloatingClick);
  }, [refs.floating]);
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: isOpen && (0, import_jsx_runtime2.jsx)(
    "div",
    {
      ref: refs.setFloating,
      style: {
        ...floatingStyles
      },
      ...getFloatingProps(),
      children
    }
  ) });
};
var defaultColors = [
  {
    color: "#e3b127",
    localization: {
      id: "yellow",
      defaultMessage: "Yellow"
    }
  },
  {
    color: "#419931",
    localization: {
      id: "green",
      defaultMessage: "Green"
    }
  },
  {
    color: "#4286c9",
    localization: {
      id: "blue",
      defaultMessage: "Blue"
    }
  },
  {
    color: "#f246b6",
    localization: {
      id: "pink",
      defaultMessage: "Pink"
    }
  },
  {
    color: "#a53dd1",
    localization: {
      id: "purple",
      defaultMessage: "Purple"
    }
  },
  {
    color: "#f09037",
    localization: {
      id: "orange",
      defaultMessage: "Orange"
    }
  },
  {
    color: "#37f0d4",
    localization: {
      id: "teal",
      defaultMessage: "Teal"
    }
  },
  {
    color: "#3d0ff5",
    localization: {
      id: "purple",
      defaultMessage: "Purple"
    }
  },
  {
    color: "#f50f26",
    localization: {
      id: "red",
      defaultMessage: "Red"
    }
  }
];
var ColorSelectionTool = ({
  highlighterColors = defaultColors,
  onColorSelection
}) => {
  return (0, import_jsx_runtime2.jsx)(SelectionTooltip, { children: (0, import_jsx_runtime2.jsx)(
    "div",
    {
      style: {
        display: "flex",
        gap: "0.5rem",
        padding: "0.5rem",
        backgroundColor: "#363636",
        borderRadius: "0.5rem"
      },
      children: highlighterColors.map((colorItem, index3) => (0, import_jsx_runtime2.jsx)(
        "button",
        {
          onClick: () => onColorSelection(colorItem),
          title: colorItem.localization.defaultMessage,
          "aria-label": colorItem.localization.defaultMessage,
          style: {
            width: "1.25rem",
            height: "1.25rem",
            borderRadius: "0.25rem",
            cursor: "pointer",
            backgroundColor: colorItem.color
          }
        },
        index3
      ))
    }
  ) });
};
var getEndOfHighlight = (selection) => {
  const lastRectangle = selection.rectangles[selection.rectangles.length - 1];
  return lastRectangle.left + lastRectangle.width + 10;
};
var getMidHeightOfHighlightLine = (selection) => {
  const lastRectangle = selection.rectangles[selection.rectangles.length - 1];
  return lastRectangle.top + lastRectangle.height / 2;
};
var ColoredHighlightComponent = ({
  selection
}) => {
  const deleteColoredHighlight = usePdf(
    (state) => state.deleteColoredHighlight
  );
  const [showButton, setShowButton] = (0, import_react5.useState)(false);
  return (0, import_jsx_runtime2.jsxs)("div", { className: "colored-highlight", children: [
    selection.rectangles.map((rect, index3) => (0, import_jsx_runtime2.jsx)(
      "span",
      {
        onClick: () => setShowButton(!showButton),
        style: {
          position: "absolute",
          top: rect.top,
          left: rect.left,
          height: rect.height,
          width: rect.width,
          cursor: "pointer",
          zIndex: 30,
          backgroundColor: selection.color,
          // mixBlendMode: "lighten", // changes the color of the text
          mixBlendMode: "darken",
          // best results
          // mixBlendMode: "multiply", // works but coloring has some inconsistencies
          borderRadius: "0.2rem"
        }
      },
      `${selection.uuid}-${index3}`
    )),
    showButton && (0, import_jsx_runtime2.jsx)(
      "button",
      {
        style: {
          backgroundColor: "white",
          color: "white",
          borderRadius: "5px",
          padding: "5px",
          cursor: "pointer",
          boxShadow: "2px 2px 5px black",
          position: "absolute",
          top: getMidHeightOfHighlightLine(selection),
          left: getEndOfHighlight(selection),
          zIndex: 30,
          transform: "translateY(-50%)"
        },
        onClick: () => deleteColoredHighlight(selection.uuid),
        children: (0, import_jsx_runtime2.jsx)(
          "svg",
          {
            fill: "#000000",
            version: "1.1",
            id: "Capa_1",
            xmlns: "http://www.w3.org/2000/svg",
            width: "15px",
            height: "15px",
            viewBox: "0 0 485 485",
            children: (0, import_jsx_runtime2.jsx)("g", { children: (0, import_jsx_runtime2.jsxs)("g", { children: [
              (0, import_jsx_runtime2.jsx)("rect", { x: "67.224", width: "350.535", height: "71.81" }),
              (0, import_jsx_runtime2.jsx)(
                "path",
                {
                  d: "M417.776,92.829H67.237V485h350.537V92.829H417.776z M165.402,431.447h-28.362V146.383h28.362V431.447z M256.689,431.447\n			h-28.363V146.383h28.363V431.447z M347.97,431.447h-28.361V146.383h28.361V431.447z"
                }
              )
            ] }) })
          }
        )
      },
      `${selection.uuid}-delete-button`
    )
  ] });
};
var ColoredHighlightLayer = ({
  onHighlight
}) => {
  const pageNumber = usePDFPageNumber();
  const { getDimension } = useSelectionDimensions();
  const highlights = usePdf(
    (state) => state.coloredHighlights
  );
  const addColoredHighlight = usePdf((state) => state.addColoredHighlight);
  const handleHighlighting = (0, import_react5.useCallback)(
    (color) => {
      const dimension = getDimension();
      if (!dimension) return;
      const { highlights: highlights2, text } = dimension;
      if (highlights2[0]) {
        const highlight = {
          uuid: v4_default(),
          pageNumber: highlights2[0].pageNumber,
          // usePDFPageNumber() doesn't return the correct page number, so i'm getting the number directly from the first highlight
          color,
          rectangles: highlights2,
          text
        };
        addColoredHighlight(highlight);
        if (onHighlight) onHighlight(highlight);
      }
    },
    [onHighlight, getDimension, addColoredHighlight]
  );
  return (0, import_jsx_runtime2.jsxs)("div", { className: "colored-highlights-layer", children: [
    highlights.filter((selection) => selection.pageNumber === pageNumber).map((selection) => (0, import_jsx_runtime2.jsx)(
      ColoredHighlightComponent,
      {
        selection
      },
      selection.uuid
    )),
    (0, import_jsx_runtime2.jsx)(
      ColorSelectionTool,
      {
        onColorSelection: (colorItem) => handleHighlighting(colorItem.color)
      }
    )
  ] });
};
var CustomLayer = ({
  children
}) => {
  const pageNumber = usePDFPageNumber();
  return children(pageNumber);
};
var convertToPercentString = (rect) => {
  return {
    top: `${rect.top}%`,
    left: `${rect.left}%`,
    height: `${rect.height}%`,
    width: `${rect.width}%`
  };
};
var HighlightLayer = (0, import_react5.forwardRef)(({ asChild, className, style, ...props }, ref) => {
  const pageNumber = usePDFPageNumber();
  const highlights = usePdf((state) => state.highlights);
  const Comp = asChild ? Slot : "div";
  const rects = highlights.filter((area) => area.pageNumber === pageNumber);
  if (!(rects == null ? void 0 : rects.length)) return null;
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: rects.map((rect, index3) => {
    const { pageNumber: pageNumber2, type, style: customStyle, ...coordinates } = rect;
    let dimensions = coordinates;
    if (type === "percent") {
      dimensions = convertToPercentString(rect);
    }
    const customStyles = customStyle ? customStyle(rect) : {};
    return (0, import_jsx_runtime2.jsx)(
      Comp,
      {
        ref,
        className,
        style: {
          position: "absolute",
          ...dimensions,
          pointerEvents: "none",
          zIndex: 30,
          ...style,
          ...customStyles
        },
        ...props,
        children: props.children
      },
      `highlight-${pageNumber2}-${index3}`
    );
  }) });
});
HighlightLayer.displayName = "HighlightLayer";
var createTextSelectionManager = () => {
  const textLayers = /* @__PURE__ */ new Map();
  let selectionChangeAbortController = null;
  let isPointerDown = false;
  let prevRange = null;
  let isFirefox;
  const removeGlobalSelectionListener = (textLayerDiv) => {
    textLayers.delete(textLayerDiv);
    if (textLayers.size === 0) {
      selectionChangeAbortController == null ? void 0 : selectionChangeAbortController.abort();
      selectionChangeAbortController = null;
    }
  };
  const enableGlobalSelectionListener = () => {
    if (selectionChangeAbortController) {
      return;
    }
    selectionChangeAbortController = new AbortController();
    const { signal } = selectionChangeAbortController;
    const reset = (endDiv, textLayer) => {
      if (endDiv.parentNode !== textLayer) {
        textLayer.appendChild(endDiv);
      }
      endDiv.style.width = "";
      endDiv.style.height = "";
      textLayer.classList.remove("selecting");
    };
    document.addEventListener(
      "pointerdown",
      () => {
        isPointerDown = true;
      },
      { signal }
    );
    document.addEventListener(
      "pointerup",
      () => {
        isPointerDown = false;
        textLayers.forEach(reset);
      },
      { signal }
    );
    window.addEventListener(
      "blur",
      () => {
        isPointerDown = false;
        textLayers.forEach(reset);
      },
      { signal }
    );
    document.addEventListener(
      "keyup",
      () => {
        if (!isPointerDown) {
          textLayers.forEach(reset);
        }
      },
      { signal }
    );
    document.addEventListener(
      "selectionchange",
      () => {
        var _a;
        const selection = document.getSelection();
        if (!selection || selection.rangeCount === 0) {
          textLayers.forEach(reset);
          return;
        }
        const activeTextLayers = /* @__PURE__ */ new Set();
        for (let i2 = 0; i2 < selection.rangeCount; i2++) {
          const range = selection.getRangeAt(i2);
          for (const textLayerDiv of textLayers.keys()) {
            if (!activeTextLayers.has(textLayerDiv) && range.intersectsNode(textLayerDiv)) {
              activeTextLayers.add(textLayerDiv);
            }
          }
        }
        for (const [textLayerDiv, endDiv] of textLayers) {
          if (activeTextLayers.has(textLayerDiv)) {
            textLayerDiv.classList.add("selecting");
          } else {
            reset(endDiv, textLayerDiv);
          }
        }
        if (isFirefox === void 0) {
          const firstTextLayer = textLayers.keys().next().value;
          if (firstTextLayer) {
            isFirefox = getComputedStyle(firstTextLayer).getPropertyValue(
              "-moz-user-select"
            ) === "none";
          }
        }
        if (isFirefox) {
          return;
        }
        try {
          const range = selection.getRangeAt(0);
          const modifyStart = prevRange && (range.compareBoundaryPoints(Range.END_TO_END, prevRange) === 0 || range.compareBoundaryPoints(Range.START_TO_END, prevRange) === 0);
          let anchor = modifyStart ? range.startContainer : range.endContainer;
          if (anchor.nodeType === Node.TEXT_NODE) {
            anchor = anchor.parentNode;
          }
          const parentTextLayer = (_a = anchor.parentElement) == null ? void 0 : _a.closest(
            ".textLayer"
          );
          const endDiv = textLayers.get(parentTextLayer);
          if (endDiv && parentTextLayer) {
            endDiv.style.width = parentTextLayer.style.width;
            endDiv.style.height = parentTextLayer.style.height;
            const insertTarget = modifyStart ? anchor : anchor.nextSibling;
            if (anchor.parentElement && insertTarget) {
              anchor.parentElement.insertBefore(endDiv, insertTarget);
            }
          }
          prevRange = range.cloneRange();
        } catch {
        }
      },
      { signal }
    );
  };
  const bindMouseEvents2 = (textLayerDiv, endOfContent) => {
    if (textLayerDiv._textSelectionBound) {
      return;
    }
    textLayerDiv._textSelectionBound = true;
    textLayers.set(textLayerDiv, endOfContent);
    enableGlobalSelectionListener();
    const handleMouseDown = () => {
      textLayerDiv.classList.add("selecting");
    };
    textLayerDiv.addEventListener("mousedown", handleMouseDown);
    textLayerDiv._cleanupTextSelection = () => {
      textLayerDiv.removeEventListener("mousedown", handleMouseDown);
      removeGlobalSelectionListener(textLayerDiv);
      delete textLayerDiv._textSelectionBound;
    };
  };
  return bindMouseEvents2;
};
var bindMouseEvents = createTextSelectionManager();
var useTextLayer = () => {
  const textContainerRef = (0, import_react5.useRef)(null);
  const textLayerRef = (0, import_react5.useRef)(null);
  const isRenderingRef = (0, import_react5.useRef)(false);
  const pageNumber = usePDFPageNumber();
  const pdfPageProxy = usePdf((state) => state.getPdfPageProxy(pageNumber));
  (0, import_react5.useEffect)(() => {
    const textContainer = textContainerRef.current;
    if (!textContainer || isRenderingRef.current) {
      return;
    }
    isRenderingRef.current = true;
    textContainer.innerHTML = "";
    if (textLayerRef.current) {
      textLayerRef.current.cancel();
      textLayerRef.current = null;
    }
    const textLayer = new __webpack_exports__TextLayer({
      textContentSource: pdfPageProxy.streamTextContent(),
      container: textContainer,
      viewport: pdfPageProxy.getViewport({ scale: 1 })
    });
    textLayerRef.current = textLayer;
    textLayer.render().then(() => {
      if (textLayerRef.current === textLayer && textContainer) {
        const endOfContent = document.createElement("div");
        endOfContent.className = "endOfContent";
        textContainer.appendChild(endOfContent);
        bindMouseEvents(textContainer, endOfContent);
      }
    }).catch((error2) => {
      if (error2.name !== "AbortException") {
        console.error("TextLayer rendering error:", error2);
      }
    }).finally(() => {
      isRenderingRef.current = false;
    });
    return () => {
      isRenderingRef.current = false;
      if (textLayerRef.current) {
        textLayerRef.current.cancel();
        textLayerRef.current = null;
      }
      if (textContainer == null ? void 0 : textContainer._cleanupTextSelection) {
        textContainer._cleanupTextSelection();
        delete textContainer._cleanupTextSelection;
      }
    };
  }, [pdfPageProxy.streamTextContent, pdfPageProxy.getViewport]);
  return {
    textContainerRef,
    pageNumber: pdfPageProxy.pageNumber
  };
};
var TextLayer2 = ({
  className,
  style,
  ...props
}) => {
  const { textContainerRef, pageNumber } = useTextLayer();
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: clsx_default("textLayer", className),
      style: {
        ...style,
        position: "absolute",
        top: 0,
        left: 0
      },
      ...props,
      ...{
        "data-page-number": pageNumber
      },
      ref: textContainerRef
    }
  );
};
var usePDFOutline = () => {
  const pdfDocumentProxy = usePdf((state) => state.pdfDocumentProxy);
  const [outline, setOutline] = (0, import_react5.useState)();
  (0, import_react5.useEffect)(() => {
    const { promise: outline2, cancel } = cancellable(
      pdfDocumentProxy.getOutline()
    );
    outline2.then(
      (result) => {
        setOutline(result);
      },
      () => {
      }
    );
    return () => {
      cancel();
    };
  }, [pdfDocumentProxy]);
  return outline;
};
var HTMLTags = [
  "a",
  "button",
  "div",
  "aside",
  "section",
  "main",
  "ul",
  "li",
  "input",
  "canvas"
];
var makePrimitive = (htmlTag) => {
  const primitive = (0, import_react5.forwardRef)(
    (props, ref) => {
      const Renderer = htmlTag;
      return (0, import_jsx_runtime2.jsx)(Renderer, { ...props, ref });
    }
  );
  primitive.displayName = `PDFReader.${htmlTag}`;
  return primitive;
};
var Primitive = HTMLTags.reduce((acc, tag) => {
  acc[tag] = makePrimitive(tag);
  return acc;
}, {});
var OutlineChildItems = ({
  ...props
}) => {
  return (0, import_jsx_runtime2.jsx)(Primitive.ul, { ...props });
};
var OutlineItem = ({
  level = 0,
  item,
  children,
  outlineItem,
  ...props
}) => {
  if (!item || !outlineItem || !children) {
    throw new Error("Outline item is required");
  }
  const pdfDocumentProxy = usePdf((state) => state.pdfDocumentProxy);
  const { jumpToPage } = usePdfJump();
  const getDestinationPage = (0, import_react5.useCallback)(
    async (dest) => {
      let explicitDest;
      if (typeof dest === "string") {
        explicitDest = await pdfDocumentProxy.getDestination(dest);
      } else if (Array.isArray(dest)) {
        explicitDest = dest;
      } else {
        explicitDest = await dest;
      }
      if (!explicitDest) {
        return;
      }
      const explicitRef = explicitDest[0];
      const page = await pdfDocumentProxy.getPageIndex(explicitRef);
      return page;
    },
    [pdfDocumentProxy]
  );
  const navigate = (0, import_react5.useCallback)(() => {
    if (!item.dest) {
      return;
    }
    getDestinationPage(item.dest).then((page) => {
      if (!page) {
        return;
      }
      jumpToPage(page, { behavior: "smooth" });
    });
  }, [item.dest, jumpToPage, getDestinationPage]);
  return (0, import_jsx_runtime2.jsxs)(Primitive.li, { ...props, children: [
    (0, import_jsx_runtime2.jsx)(
      "a",
      {
        role: "button",
        tabIndex: 0,
        onClick: navigate,
        onKeyUp: (e2) => {
          if (e2.key === "Enter") {
            navigate();
          }
        },
        "data-level": level,
        children: item.title
      }
    ),
    item.items && item.items.length > 0 && (0, import_react5.cloneElement)(children, {
      // @ts-expect-error we are missing the corect props types
      children: item.items.map(
        (item2, index3) => (0, import_react5.cloneElement)(outlineItem, {
          // @ts-expect-error we are missing the corect props types
          level: level + 1,
          item: item2,
          outlineItem,
          // biome-ignore lint/suspicious/noArrayIndexKey: <stuff>
          key: index3
        })
      )
    })
  ] });
};
var Outline = ({
  children,
  ...props
}) => {
  const outline = usePDFOutline();
  return (0, import_jsx_runtime2.jsx)(Primitive.ul, { ...props, children: outline == null ? void 0 : outline.map((item, idx) => {
    return (0, import_react5.cloneElement)(children, {
      key: idx,
      item,
      outlineItem: children
    });
  }) });
};
var Page = ({
  children,
  pageNumber = 1,
  style,
  ...props
}) => {
  const pdfPageProxy = usePdf((state) => state.getPdfPageProxy(pageNumber));
  const width = (pdfPageProxy.view[2] ?? 0) - (pdfPageProxy.view[0] ?? 0);
  const height = (pdfPageProxy.view[3] ?? 0) - (pdfPageProxy.view[1] ?? 0);
  return (0, import_jsx_runtime2.jsx)(PDFPageNumberContext.Provider, { value: pdfPageProxy.pageNumber, children: (0, import_jsx_runtime2.jsx)(
    Primitive.div,
    {
      style: {
        display: "block"
      },
      children: (0, import_jsx_runtime2.jsx)(
        "div",
        {
          style: {
            ...style,
            "--scale-factor": 1,
            "--total-scale-factor": 1,
            position: "relative",
            width,
            height
          },
          ...props,
          children
        }
      )
    }
  ) });
};
var NextPage = () => {
};
var PreviousPage = () => {
};
var CurrentPage = ({ ...props }) => {
  const currentPage = usePdf((state) => state.currentPage);
  const pages = usePdf((state) => state.pdfDocumentProxy.numPages);
  const [pageNumber, setPageNumber] = (0, import_react5.useState)(currentPage);
  const isSelected = (0, import_react5.useRef)(false);
  const { jumpToPage } = usePdfJump();
  (0, import_react5.useEffect)(() => {
    if (isSelected.current) {
      return;
    }
    setPageNumber(currentPage);
  }, [currentPage]);
  return (0, import_jsx_runtime2.jsx)(
    "input",
    {
      type: "number",
      ...props,
      style: {
        ...props.style,
        appearance: "textfield",
        MozAppearance: "textfield",
        WebkitAppearance: "none"
      },
      value: pageNumber,
      onChange: (e2) => {
        setPageNumber(e2.target.value);
      },
      onClick: () => {
        isSelected.current = true;
      },
      onBlur: (e2) => {
        if (currentPage !== Number(e2.target.value)) {
          jumpToPage(Number(e2.target.value), {
            behavior: "auto"
          });
        }
        isSelected.current = false;
      },
      onKeyDown: (e2) => {
        e2.key === "Enter" && e2.currentTarget.blur();
      },
      min: 1,
      max: pages
    }
  );
};
var TotalPages = ({ ...props }) => {
  const pages = usePdf((state) => state.pdfDocumentProxy.numPages);
  return (0, import_jsx_runtime2.jsx)("div", { ...props, children: pages });
};
var useFitWidth = ({ viewportRef }) => {
  const viewports = usePdf((state) => state.viewports);
  const zoomOptions = usePdf((state) => state.zoomOptions);
  const updateZoom = usePdf((state) => state.updateZoom);
  const store = PDFStore.useContext();
  (0, import_react5.useLayoutEffect)(() => {
    if (viewportRef.current === null) return;
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const isFitWidth = store.getState().isZoomFitWidth;
        if (entry.target === viewportRef.current && isFitWidth) {
          const containerWidth = entry.contentRect.width;
          const newZoom = getFitWidthZoom(
            containerWidth,
            viewports,
            zoomOptions
          );
          updateZoom(newZoom, true);
        }
      }
    });
    resizeObserver.observe(viewportRef.current);
    return () => {
      resizeObserver.disconnect();
    };
  }, [store, updateZoom, viewportRef, viewports, zoomOptions]);
  return null;
};
var supportsScrollend2 = typeof window === "undefined" ? true : "onscrollend" in window;
var addEventListenerOptions2 = {
  passive: true
};
var useObserveElement = () => {
  const store = PDFStore.useContext();
  const observeElementOffset2 = (instance, cb) => {
    const element = instance.scrollElement;
    if (!element) {
      return;
    }
    const targetWindow = instance.targetWindow;
    if (!targetWindow) {
      return;
    }
    let offset32 = 0;
    const fallback = instance.options.useScrollendEvent && supportsScrollend2 ? () => void 0 : debounce(
      targetWindow,
      () => {
        cb(offset32, false);
      },
      instance.options.isScrollingResetDelay
    );
    const createHandler = (isScrolling) => () => {
      const { horizontal, isRtl } = instance.options;
      offset32 = horizontal ? element.scrollLeft * (isRtl && -1 || 1) : element.scrollTop;
      const zoom = store.getState().zoom;
      offset32 = offset32 / zoom;
      fallback();
      cb(offset32, isScrolling);
    };
    const handler = createHandler(true);
    const endHandler = createHandler(false);
    endHandler();
    element.addEventListener("scroll", handler, addEventListenerOptions2);
    element.addEventListener("scrollend", endHandler, addEventListenerOptions2);
    return () => {
      element.removeEventListener("scroll", handler);
      element.removeEventListener("scrollend", endHandler);
    };
  };
  return {
    observeElementOffset: observeElementOffset2
  };
};
var useScrollFn = () => {
  const store = PDFStore.useContext();
  const scrollToFn = (0, import_react5.useCallback)(
    (_offset, canSmooth, instance) => {
      const zoom = store.getState().zoom;
      const offset32 = _offset * zoom;
      elementScroll(offset32, canSmooth, instance);
    },
    [store]
  );
  return { scrollToFn };
};
var useVisiblePage = ({ items }) => {
  const zoomLevel = usePdf((state) => state.zoom);
  const isPinching = usePdf((state) => state.isPinching);
  const setCurrentPage = usePdf((state) => state.setCurrentPage);
  const scrollElement = usePdf((state) => {
    var _a;
    return (_a = state.viewportRef) == null ? void 0 : _a.current;
  });
  const calculateVisiblePageIndex = (0, import_react5.useCallback)(
    (virtualItems) => {
      if (!scrollElement || virtualItems.length === 0) return 0;
      const scrollTop = scrollElement.scrollTop / zoomLevel;
      const viewportHeight = scrollElement.clientHeight / zoomLevel;
      const viewportCenter = scrollTop + viewportHeight / 2;
      let closestIndex = 0;
      let smallestDistance = Infinity;
      for (const item of virtualItems) {
        const itemCenter = item.start + item.size / 2;
        const distance = Math.abs(itemCenter - viewportCenter);
        if (distance < smallestDistance * 0.8) {
          smallestDistance = distance;
          closestIndex = item.index;
        }
      }
      return closestIndex;
    },
    [scrollElement, zoomLevel]
  );
  (0, import_react5.useEffect)(() => {
    if (!isPinching && items.length > 0) {
      const mostVisibleIndex = calculateVisiblePageIndex(items);
      setCurrentPage == null ? void 0 : setCurrentPage(mostVisibleIndex + 1);
    }
  }, [items, isPinching, calculateVisiblePageIndex, setCurrentPage]);
  return null;
};
function clamp22(v, min2, max2) {
  return Math.max(min2, Math.min(v, max2));
}
var V = {
  toVector(v, fallback) {
    if (v === void 0) v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min2, max2, constant = 0.15) {
  if (constant === 0) return clamp22(position, min2, max2);
  if (position < min2) return -rubberband(min2 - position, max2 - min2, constant) + min2;
  if (position > max2) return +rubberband(position - max2, max2 - min2, constant) + max2;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e2, r22) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r22 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r22 = 1; r22 < arguments.length; r22++) {
    var t2 = null != arguments[r22] ? arguments[r22] : {};
    r22 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string) return "";
  return string[0].toUpperCase() + string.slice(1);
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive) eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event)) return "touch";
  if ("pointerType" in event) return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e2) => {
    var _event$currentTarget, _event$currentTarget$;
    return e2.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e2.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  } catch (_unused) {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event) payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v, ...args) {
  if (typeof v === "function") {
    return v(...args);
  } else {
    return v;
  }
}
function noop3() {
}
function chain(...fns) {
  if (fns.length === 0) return noop3;
  if (fns.length === 1) return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable) state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent) this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional) return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config) state._bounds = call(config.bounds, state);
          if (this.setup) this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active) this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
    const memo2 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo2 !== void 0) state.memo = memo2;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v[1] = 0;
          break;
        case "y":
          v[0] = 0;
          break;
      }
    }
  }
};
var identity2 = (v) => v;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function") return value;
    if (value != null) return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity2;
      return (v) => {
        const r22 = originalTransform(v);
        if (!isFinite(r22[0]) || !isFinite(r22[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r22[0]},${[1]}]`);
        }
        return r22;
      };
    }
    return transform || identity2;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var DEFAULT_AXIS_THRESHOLD = 0;
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection) return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});
var KEYS_DELTA_MAP = {
  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],
  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],
  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],
  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;
    const ctrlIds = this.ctrl.setEventIds(event);
    if (config.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config.preventScrollAxis && getPointerType(event) !== "mouse") {
      state._active = false;
      this.setupScrollPrevention(event);
    } else if (config.delay > 0) {
      this.setupDelayTrigger(event);
      if (config.triggerAllEvents) {
        this.compute(event);
        this.emit();
      }
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId) return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed && state.intentional) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config.preventScrollAxis && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (true) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config = this.config;
    if (!state._active || !state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId) return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;
    if (state.tap && config.filterTaps) {
      state._force = true;
    } else {
      const [_dx, _dy] = state._delta;
      const [_mx, _my] = state._movement;
      const [svx, svy] = config.swipe.velocity;
      const [sx, sy] = config.swipe.distance;
      const sdt = config.swipe.duration;
      if (state.elapsedTime < sdt) {
        const _vx = Math.abs(_dx / state.timeDelta);
        const _vy = Math.abs(_dy / state.timeDelta);
        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);
        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap && event.detail > 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config = this.config;
    const device = config.device;
    if (true) {
      try {
        if (device === "pointer" && config.preventScrollDelay === void 0) {
          const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {
      }
    }
    if (config.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    this.state._preventScroll = false;
    persistEvent(event);
    const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0];
      this.startPointerDrag(event);
    }, this.config.delay);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      this.start(event);
      state._delta = deltaFn(this.config.keyboardDisplacement, factor);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP)) return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
      bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
    }
    if (this.config.keys) {
      bindFunction("key", "down", this.keyDown.bind(this));
      bindFunction("key", "up", this.keyUp.bind(this));
    }
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true,
        passive: false
      });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e2) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_KEYBOARD_DISPLACEMENT = 10;
var DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return "touch";
    if (this.pointerLock) return "mouse";
    if (SUPPORT.pointer && !mouse) return "pointer";
    if (SUPPORT.touch) return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 100;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset: offset32,
      lastOffset
    } = this.state;
    this.state.movement = [offset32[0] / lastOffset[0], offset32[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0) state.axis = "angle";
      else if (axisMovementDifference > 0) state.axis = "scale";
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale") v[1] = 0;
      else if (this.state.axis === "angle") v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return;
    }
    if (ctrlTouchIds.size < 2) return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2) return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active) return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active) return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active) return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active) return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    if (state._active) return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable) event.preventDefault();
    if (!this.state._active) return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find((k) => event[k]) : !event[modifierKey])) return;
    if (!this.state._active) this.wheelStart(event);
    else this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
    if (SUPPORT.touch && touch) return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return "pointer";
      if (SUPPORT.touch) return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0) return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
var MoveEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    if (!this.state._active) this.moveStart(event);
    else this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active) return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var ScrollEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active) this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};
var scrollConfigResolver = coordinatesConfigResolver;
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active) this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var HoverEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    const state = this.state;
    if (!state._active) return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (true) {
          const r22 = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r22)) result[key] = r22;
        } else {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver) result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse2(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove);
    };
    listeners.add(remove);
    return remove;
  }
  clean() {
    this._listeners.forEach((remove) => remove());
    this._listeners.clear();
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout) window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller = class {
  constructor(handlers) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse2(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target) this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target) return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target) return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, "drag");
  if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
  if (internalHandlers.move) setupGesture(ctrl, "move");
  if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
  if (internalHandlers.hover) setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive) handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers) {
  const native = {};
  const handlers = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers[key];
    } else {
      native[key] = _handlers[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey)) return;
  if (!EngineMap.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo2 = void 0;
    if (state.first && startKey in handlers) handlers[startKey](state);
    if (handlerKey in handlers) memo2 = handlers[handlerKey](state);
    if (state.last && endKey in handlers) handlers[endKey](state);
    return memo2;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}
function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react5.default.useMemo(() => new Controller(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  import_react5.default.useEffect(ctrl.effect.bind(ctrl));
  import_react5.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers, _config) {
    const {
      handlers,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers, _config || {});
    return useRecognizers(handlers, config, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config || {});
}
var firstMemo = (first, memo2, initializer) => {
  if (!first && !memo2) {
    throw new Error(
      "Missing memo initialization. You likely forgot to return the result of `firstMemo` in the event function"
    );
  }
  if (first) {
    return initializer();
  }
  return memo2;
};
var useViewportContainer = ({
  containerRef,
  elementWrapperRef,
  elementRef
}) => {
  const [origin, setOrigin] = (0, import_react5.useState)([0, 0]);
  const { maxZoom, minZoom } = usePdf((state) => state.zoomOptions);
  const zoom = usePdf((state) => state.zoom);
  const viewportRef = usePdf((state) => state.viewportRef);
  const setIsPinching = usePdf((state) => state.setIsPinching);
  const updateZoom = usePdf((state) => state.updateZoom);
  (0, import_react5.useEffect)(() => {
    viewportRef.current = containerRef.current;
  }, [containerRef, viewportRef]);
  const transformations = (0, import_react5.useRef)({
    translateX: 0,
    translateY: 0,
    zoom
  });
  const updateTransform = (0, import_react5.useCallback)(
    (zoomUpdate) => {
      if (!elementRef.current || !containerRef.current || !elementWrapperRef.current) {
        return;
      }
      const { zoom: zoom2, translateX, translateY } = transformations.current;
      elementRef.current.style.transform = `scale3d(${zoom2}, ${zoom2}, 1)`;
      elementRef.current.style.willChange = "scale3d";
      const elementBoundingBox = elementRef.current.getBoundingClientRect();
      const width = elementBoundingBox.width;
      elementWrapperRef.current.style.width = `${width}px`;
      elementWrapperRef.current.style.height = `${elementBoundingBox.height}px`;
      containerRef.current.scrollTop = translateY;
      containerRef.current.scrollLeft = translateX;
      if (zoomUpdate) updateZoom(() => transformations.current.zoom);
    },
    [containerRef, elementRef, elementWrapperRef, updateZoom]
  );
  (0, import_react5.useEffect)(() => {
    if (transformations.current.zoom === zoom || !containerRef.current) {
      return;
    }
    const dZoom = zoom / transformations.current.zoom;
    transformations.current = {
      translateX: containerRef.current.scrollLeft * dZoom,
      translateY: containerRef.current.scrollTop * dZoom,
      zoom
    };
    updateTransform();
  }, [containerRef, zoom, updateTransform]);
  (0, import_react5.useEffect)(() => {
    const preventDefault = (e2) => e2.preventDefault();
    document.addEventListener("gesturestart", preventDefault);
    document.addEventListener("gesturechange", preventDefault);
    return () => {
      document.removeEventListener("gesturestart", preventDefault);
      document.removeEventListener("gesturechange", preventDefault);
    };
  }, []);
  useGesture(
    {
      onPinch: ({ origin: origin2, first, movement: [ms], memo: memo2 }) => {
        const currentElement = elementRef.current;
        const currentContainer = containerRef.current;
        if (!currentElement || !currentContainer) return;
        if (!elementRef.current || !containerRef.current) return;
        const newMemo = firstMemo(first, memo2, () => {
          const elementRect = currentElement.getBoundingClientRect();
          const containerRect = currentContainer.getBoundingClientRect();
          const contentPosition = [
            origin2[0] - elementRect.left,
            origin2[1] - elementRect.top
          ];
          const containerPosition = [
            origin2[0] - containerRect.left,
            origin2[1] - containerRect.top
          ];
          setOrigin([
            contentPosition[0] / transformations.current.zoom,
            contentPosition[1] / transformations.current.zoom
          ]);
          return {
            contentPosition,
            containerPosition,
            originZoom: transformations.current.zoom,
            originTranslate: transformations.current.translateY
          };
        });
        const newZoom = clamp2(ms * newMemo.originZoom, minZoom, maxZoom);
        const realMs = newZoom / newMemo.originZoom;
        const newTranslateX = newMemo.contentPosition[0] * realMs - newMemo.containerPosition[0];
        const newTranslateY = newMemo.contentPosition[1] * realMs - newMemo.containerPosition[1];
        transformations.current = {
          zoom: newZoom,
          translateX: newTranslateX,
          translateY: newTranslateY
        };
        updateTransform(true);
        return newMemo;
      },
      onPinchStart: () => setIsPinching(true),
      onPinchEnd: () => setIsPinching(false)
    },
    {
      target: containerRef
    }
  );
  return {
    origin
  };
};
var DEFAULT_HEIGHT = 600;
var EXTRA_HEIGHT = 0;
var Pages = ({
  children,
  gap = 10,
  virtualizerOptions = { overscan: 2 },
  initialOffset,
  onOffsetChange,
  ...props
}) => {
  const [tempItems, setTempItems] = (0, import_react5.useState)([]);
  const viewports = usePdf((state) => state.viewports);
  const numPages = usePdf((state) => state.pdfDocumentProxy.numPages);
  const isPinching = usePdf((state) => state.isPinching);
  const elementWrapperRef = (0, import_react5.useRef)(null);
  const elementRef = (0, import_react5.useRef)(null);
  const containerRef = (0, import_react5.useRef)(null);
  useViewportContainer({
    elementRef,
    elementWrapperRef,
    containerRef
  });
  const setVirtualizer = usePdf((state) => state.setVirtualizer);
  const { scrollToFn } = useScrollFn();
  const { observeElementOffset: observeElementOffset2 } = useObserveElement();
  const estimateSize = (0, import_react5.useCallback)(
    (index3) => {
      if (!viewports || !viewports[index3]) return DEFAULT_HEIGHT;
      return viewports[index3].height + EXTRA_HEIGHT;
    },
    [viewports]
  );
  const virtualizer = useVirtualizer({
    count: numPages || 0,
    getScrollElement: () => containerRef.current,
    estimateSize,
    observeElementOffset: observeElementOffset2,
    overscan: (virtualizerOptions == null ? void 0 : virtualizerOptions.overscan) ?? 0,
    scrollToFn,
    gap,
    initialOffset
  });
  (0, import_react5.useEffect)(() => {
    if (onOffsetChange && virtualizer.scrollOffset)
      onOffsetChange(virtualizer.scrollOffset);
  }, [virtualizer.scrollOffset, onOffsetChange]);
  (0, import_react5.useEffect)(() => {
    setVirtualizer(virtualizer);
  }, [setVirtualizer, virtualizer]);
  (0, import_react5.useEffect)(() => {
    let timeout;
    const virtualized = virtualizer == null ? void 0 : virtualizer.getVirtualItems();
    if (!isPinching) {
      virtualizer == null ? void 0 : virtualizer.measure();
      timeout = setTimeout(() => {
        setTempItems([]);
      }, 200);
    } else if (virtualized && (virtualized == null ? void 0 : virtualized.length) > 0) {
      setTempItems(virtualized);
    }
    return () => {
      clearTimeout(timeout);
    };
  }, [isPinching, virtualizer == null ? void 0 : virtualizer.measure, virtualizer == null ? void 0 : virtualizer.getVirtualItems]);
  const virtualizerItems = (virtualizer == null ? void 0 : virtualizer.getVirtualItems()) ?? [];
  const items = tempItems.length ? tempItems : virtualizerItems;
  useVisiblePage({
    items
  });
  useFitWidth({ viewportRef: containerRef });
  const largestPageWidth = usePdf(
    (state) => Math.max(...state.viewports.map((v) => v.width))
  );
  (0, import_react5.useEffect)(() => {
    virtualizer.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size4 = virtualizer.getSize();
      const scrollOffset = virtualizer.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size4 ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size4) / 2;
      } else if (align === "end") {
        toOffset -= size4;
      }
      const scrollSizeProp = virtualizer.options.horizontal ? "scrollWidth" : "scrollHeight";
      virtualizer.scrollElement ? "document" in virtualizer.scrollElement ? (
        //@ts-expect-error this is a private stuff
        virtualizer.scrollElement.document.documentElement[scrollSizeProp]
      ) : virtualizer.scrollElement[scrollSizeProp] : 0;
      return Math.max(toOffset, 0);
    };
  }, [virtualizer]);
  return (0, import_jsx_runtime2.jsx)(
    Primitive.div,
    {
      ref: containerRef,
      ...props,
      style: {
        display: "flex",
        justifyContent: "center",
        height: "100%",
        position: "relative",
        overflow: "auto",
        ...props.style
      },
      children: (0, import_jsx_runtime2.jsx)(
        "div",
        {
          ref: elementWrapperRef,
          style: {
            width: "max-content"
          },
          children: (0, import_jsx_runtime2.jsx)(
            "div",
            {
              ref: elementRef,
              style: {
                height: `${virtualizer.getTotalSize()}px`,
                position: "absolute",
                display: "flex",
                alignItems: "center",
                flexDirection: "column",
                transformOrigin: "0 0",
                // width: "max-content",
                width: largestPageWidth,
                margin: "0 auto"
              },
              children: items.map((virtualItem) => {
                var _a;
                const innerBoxWidth = (viewports == null ? void 0 : viewports[virtualItem.index]) ? (_a = viewports[virtualItem.index]) == null ? void 0 : _a.width : 0;
                if (!innerBoxWidth) return null;
                return (0, import_jsx_runtime2.jsx)(
                  "div",
                  {
                    style: {
                      width: innerBoxWidth,
                      height: `0px`
                    },
                    children: (0, import_jsx_runtime2.jsx)(
                      "div",
                      {
                        style: {
                          height: `${virtualItem.size}px`,
                          transform: `translateY(${virtualItem.start}px)`
                        },
                        children: (0, import_react5.cloneElement)(children, {
                          key: virtualItem.key,
                          //@ts-expect-error pageNumber is not a valid react key
                          pageNumber: virtualItem.index + 1
                        })
                      }
                    )
                  },
                  virtualItem.key
                );
              })
            }
          )
        }
      )
    }
  );
};
var usePDFDocumentContext = ({
  onDocumentLoad,
  source,
  initialRotation = 0,
  isZoomFitWidth,
  zoom = 1,
  zoomOptions
}) => {
  const [_, setProgress] = (0, import_react5.useState)(0);
  const [initialState, setInitialState] = (0, import_react5.useState)();
  const [rotation] = (0, import_react5.useState)(initialRotation);
  (0, import_react5.useEffect)(() => {
    const generateViewports = async (pdf) => {
      const pageProxies = [];
      const rotations = [];
      const viewports = await Promise.all(
        Array.from({ length: pdf.numPages }, async (_2, index3) => {
          const page = await pdf.getPage(index3 + 1);
          const deltaRotate = page.rotate || 0;
          const viewport = page.getViewport({
            scale: 1,
            rotation: rotation + deltaRotate
          });
          pageProxies.push(page);
          rotations.push(page.rotate);
          return viewport;
        })
      );
      const sortedPageProxies = pageProxies.sort((a2, b) => {
        return a2.pageNumber - b.pageNumber;
      });
      setInitialState((prev) => ({
        ...prev,
        isZoomFitWidth,
        viewports,
        pageProxies: sortedPageProxies,
        pdfDocumentProxy: pdf,
        zoom,
        zoomOptions
      }));
    };
    const loadDocument = () => {
      setInitialState(null);
      setProgress(0);
      const loadingTask = __webpack_exports__getDocument(source);
      loadingTask.onProgress = (progressEvent) => {
        if (progressEvent.loaded === progressEvent.total) {
          return;
        }
        setProgress(progressEvent.loaded / progressEvent.total);
      };
      const loadingPromise = loadingTask.promise.then((proxy) => {
        onDocumentLoad == null ? void 0 : onDocumentLoad({ proxy, source });
        setProgress(1);
        generateViewports(proxy);
      }).catch((error2) => {
        if (loadingTask.destroyed) {
          return;
        }
        console.error("Error loading PDF document", error2);
      });
      return () => {
        loadingPromise.finally(() => loadingTask.destroy());
      };
    };
    loadDocument();
  }, [source]);
  return {
    initialState
  };
};
var Root = (0, import_react5.forwardRef)(
  ({
    children,
    source,
    loader,
    onDocumentLoad,
    isZoomFitWidth,
    zoom,
    zoomOptions,
    ...props
  }, ref) => {
    const { initialState } = usePDFDocumentContext({
      source,
      onDocumentLoad,
      isZoomFitWidth,
      zoom,
      zoomOptions
    });
    return (0, import_jsx_runtime2.jsx)(Primitive.div, { ref, ...props, children: initialState ? (0, import_jsx_runtime2.jsx)(PDFStore.Provider, { initialValue: initialState, children }) : loader || "Loading..." });
  }
);
Root.displayName = "Root";
var Search = ({ children, loading = "Loading..." }) => {
  const [isLoading, setIsLoading] = (0, import_react5.useState)(false);
  const proxies = usePdf((state) => state.pageProxies);
  const setTextContent = usePdf((state) => state.setTextContent);
  const getTextContent = (0, import_react5.useCallback)(
    async (pages) => {
      setIsLoading(true);
      const promises = pages.map(async (proxy) => {
        const content = await proxy.getTextContent();
        const text2 = content.items.map((item) => (item == null ? void 0 : item.str) || "").join("");
        return Promise.resolve({
          pageNumber: proxy.pageNumber,
          text: text2
        });
      });
      const text = await Promise.all(promises);
      setIsLoading(false);
      setTextContent(text);
    },
    [setTextContent]
  );
  (0, import_react5.useEffect)(() => {
    getTextContent(proxies);
  }, [proxies, getTextContent]);
  return isLoading ? loading : children;
};
var DEFAULT_CONFIG = {
  maxHeight: 800,
  maxWidth: 400
};
var useThumbnail = (pageNumber, config = {}) => {
  const {
    maxHeight = DEFAULT_CONFIG.maxHeight,
    maxWidth = DEFAULT_CONFIG.maxWidth,
    isFirstPage = false
  } = config;
  const containerRef = (0, import_react5.useRef)(null);
  const canvasRef = (0, import_react5.useRef)(null);
  const renderTaskRef = (0, import_react5.useRef)(null);
  const pageProxy = usePdf((state) => state.getPdfPageProxy(pageNumber));
  const { visible } = useVisibility({ elementRef: containerRef });
  const [debouncedVisible] = a(visible, 50);
  const dpr = useDpr();
  const isVisible = isFirstPage || debouncedVisible;
  (0, import_react5.useEffect)(() => {
    const renderThumbnail = async () => {
      const canvas = canvasRef.current;
      if (!canvas || !pageProxy) return;
      try {
        if (renderTaskRef.current) {
          renderTaskRef.current.cancel();
        }
        const viewport = pageProxy.getViewport({ scale: 1 });
        const scale = Math.min(maxWidth / viewport.width, maxHeight / viewport.height) * (isVisible ? dpr : 0.5);
        const scaledViewport = pageProxy.getViewport({ scale });
        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;
        const context = canvas.getContext("2d");
        if (!context) return;
        const renderTask = pageProxy.render({
          canvasContext: context,
          viewport: scaledViewport
        });
        renderTaskRef.current = renderTask;
        await renderTask.promise;
      } catch (error2) {
        if (error2 instanceof Error && error2.name === "RenderingCancelledException") {
          console.log("Rendering cancelled");
        } else {
          console.error("Failed to render PDF page:", error2);
        }
      }
    };
    renderThumbnail();
    return () => {
      var _a;
      (_a = renderTaskRef.current) == null ? void 0 : _a.cancel();
    };
  }, [pageProxy, isVisible, dpr, maxHeight, maxWidth]);
  return {
    canvasRef,
    containerRef,
    isVisible
  };
};
var Thumbnail = ({
  pageNumber = 1,
  ...props
}) => {
  const { canvasRef, containerRef, isVisible } = useThumbnail(pageNumber, {
    isFirstPage: pageNumber < 5
  });
  const { jumpToPage } = usePdfJump();
  return (0, import_jsx_runtime2.jsx)("div", { ref: containerRef, style: { minHeight: "150px", minWidth: "10px" }, children: isVisible && (0, import_jsx_runtime2.jsx)(
    Primitive.canvas,
    {
      ...props,
      role: "button",
      tabIndex: 0,
      onClick: (e2) => {
        if (props.onClick) {
          props.onClick(e2);
        }
        jumpToPage(pageNumber, { behavior: "auto" });
      },
      onKeyDown: (e2) => {
        if (props.onKeyDown) {
          props.onKeyDown(e2);
        }
        if (e2.key === "Enter") {
          jumpToPage(pageNumber, { behavior: "auto" });
        }
      },
      ref: canvasRef
    }
  ) });
};
var Thumbnails = ({
  children,
  ...props
}) => {
  const pageCount = usePdf((state) => state.pdfDocumentProxy.numPages);
  return (0, import_jsx_runtime2.jsx)(Primitive.div, { ...props, children: Array.from({
    length: pageCount
  }).map((_, index3) => {
    return (0, import_react5.cloneElement)(children, { key: index3, pageNumber: index3 + 1 });
  }) });
};
var ZoomIn = ({ ...props }) => {
  const setZoom = usePdf((state) => state.updateZoom);
  return (0, import_jsx_runtime2.jsx)(
    Primitive.button,
    {
      ...props,
      onClick: (e2) => {
        var _a;
        (_a = props.onClick) == null ? void 0 : _a.call(props, e2);
        setZoom((zoom) => Number((zoom + 0.1).toFixed(1)));
      }
    }
  );
};
var ZoomOut = ({ ...props }) => {
  const setZoom = usePdf((state) => state.updateZoom);
  return (0, import_jsx_runtime2.jsx)(
    Primitive.button,
    {
      ...props,
      onClick: (e2) => {
        var _a;
        (_a = props.onClick) == null ? void 0 : _a.call(props, e2);
        setZoom((zoom) => Number((zoom - 0.1).toFixed(1)));
      }
    }
  );
};
var CurrentZoom = ({ ...props }) => {
  const setRealZoom = usePdf((state) => state.updateZoom);
  const realZoom = usePdf((state) => state.zoom);
  const [zoom, setZoom] = (0, import_react5.useState)((realZoom * 100).toFixed(0));
  const isSelected = (0, import_react5.useRef)(false);
  (0, import_react5.useEffect)(() => {
    if (isSelected.current) {
      return;
    }
    setZoom((realZoom * 100).toFixed(0));
  }, [realZoom]);
  return (0, import_jsx_runtime2.jsx)(
    "input",
    {
      ...props,
      value: zoom,
      onClick: () => {
        isSelected.current = true;
      },
      onChange: (e2) => {
        setRealZoom(Number(e2.target.value) / 100);
        setZoom(e2.target.value);
      },
      onBlur: () => {
        isSelected.current = false;
        setZoom((realZoom * 100).toFixed(0));
      }
    }
  );
};
function levenshteinDistance(a2, b) {
  const matrix = [];
  for (let i2 = 0; i2 <= b.length; i2++) {
    matrix[i2] = [i2];
  }
  for (let j = 0; j <= a2.length; j++) {
    matrix[0][j] = j;
  }
  for (let i2 = 1; i2 <= b.length; i2++) {
    for (let j = 1; j <= a2.length; j++) {
      if (b.charAt(i2 - 1) === a2.charAt(j - 1)) {
        matrix[i2][j] = matrix[i2 - 1][j - 1];
      } else {
        matrix[i2][j] = Math.min(
          matrix[i2 - 1][j - 1] + 1,
          matrix[i2][j - 1] + 1,
          matrix[i2 - 1][j] + 1
        );
      }
    }
  }
  return matrix[b.length][a2.length];
}
var useSearch = () => {
  const textContent = usePdf((state) => state.textContent);
  const [keywords] = (0, import_react5.useState)([]);
  const [searchResults, setSearchResults] = (0, import_react5.useState)({
    exactMatches: [],
    fuzzyMatches: [],
    hasMoreResults: false
  });
  const findExactMatches = (0, import_react5.useCallback)(
    (searchText, text, pageNumber, textSize) => {
      const results = [];
      const textLower = text.toLowerCase();
      const searchLower = searchText.toLowerCase();
      let index3 = 0;
      while (true) {
        const matchIndex = textLower.indexOf(searchLower, index3);
        if (matchIndex === -1) break;
        results.push({
          pageNumber,
          text: text.substr(matchIndex, searchText.length + textSize),
          score: 1,
          matchIndex,
          isExactMatch: true,
          searchText
        });
        index3 = matchIndex + searchText.length;
      }
      return results;
    },
    []
  );
  const findFuzzyMatches = (0, import_react5.useCallback)(
    (searchText, text, pageNumber, threshold, excludeIndices, textSize) => {
      const results = [];
      const textLower = text.toLowerCase();
      const searchLower = searchText.toLowerCase();
      let index3 = 0;
      while (index3 < textLower.length) {
        if (excludeIndices.has(index3)) {
          index3++;
          continue;
        }
        const chunk = textLower.substr(index3, searchLower.length + 10);
        const distance = levenshteinDistance(
          searchLower,
          chunk.substr(0, searchLower.length)
        );
        const maxDistance = Math.floor(searchLower.length * (1 - threshold));
        if (distance <= maxDistance && distance > 0) {
          const score = 1 - distance / searchLower.length;
          results.push({
            pageNumber,
            text: text.substr(index3, searchLower.length + textSize),
            score,
            matchIndex: index3,
            isExactMatch: false,
            searchText
          });
          index3 += searchLower.length;
        } else {
          index3++;
        }
      }
      return results;
    },
    []
  );
  const search = (0, import_react5.useCallback)(
    (searchText, options = {}) => {
      const { threshold = 0.7, limit = 10, textSize = 100 } = options;
      if (!searchText.trim()) {
        const emptyResults = {
          exactMatches: [],
          fuzzyMatches: [],
          hasMoreResults: false
        };
        setSearchResults(emptyResults);
        return emptyResults;
      }
      let exactMatches = [];
      let fuzzyMatches = [];
      const exactMatchIndices = /* @__PURE__ */ new Set();
      textContent.forEach(({ pageNumber, text }) => {
        const matches2 = findExactMatches(
          searchText,
          text,
          pageNumber,
          textSize
        );
        exactMatches = [...exactMatches, ...matches2];
        matches2.forEach((match) => {
          for (let i2 = 0; i2 < searchText.length; i2++) {
            exactMatchIndices.add(match.matchIndex + i2);
          }
        });
      });
      textContent.forEach(({ pageNumber, text }) => {
        const matches2 = findFuzzyMatches(
          searchText,
          text,
          pageNumber,
          threshold,
          exactMatchIndices,
          textSize
        );
        fuzzyMatches = [...fuzzyMatches, ...matches2];
      });
      exactMatches.sort((a2, b) => b.score - a2.score);
      fuzzyMatches.sort((a2, b) => b.score - a2.score);
      const exactLimit = Math.min(exactMatches.length, Math.ceil(limit / 2));
      const fuzzyLimit = Math.min(fuzzyMatches.length, limit - exactLimit);
      const limitedResults = {
        exactMatches: exactMatches.slice(0, exactLimit),
        fuzzyMatches: fuzzyMatches.slice(0, fuzzyLimit),
        hasMoreResults: exactMatches.length + fuzzyMatches.length > limit
      };
      setSearchResults(limitedResults);
      return limitedResults;
    },
    [textContent, findExactMatches, findFuzzyMatches]
  );
  return {
    textContent,
    keywords,
    searchResults,
    search
  };
};
async function calculateHighlightRects(pageProxy, textMatch) {
  const textContent = await pageProxy.getTextContent();
  const items = textContent.items;
  const matchLength = textMatch.searchText ? textMatch.searchText.length : textMatch.text.length;
  const matchRects = [];
  let currentIndex = 0;
  let remainingMatchLength = matchLength;
  let foundStart = false;
  const viewport = pageProxy.getViewport({ scale: 1 });
  for (let i2 = 0; i2 < items.length; i2++) {
    const item = items[i2];
    if (!item) continue;
    const itemLength = item.str.length;
    if (!foundStart && currentIndex <= textMatch.matchIndex && textMatch.matchIndex < currentIndex + itemLength) {
      foundStart = true;
      const matchStartInItem = textMatch.matchIndex - currentIndex;
      const matchLengthInItem = Math.min(
        itemLength - matchStartInItem,
        remainingMatchLength
      );
      const transform = item.transform;
      const y = viewport.height - (transform[5] + item.height);
      const rect = {
        pageNumber: textMatch.pageNumber,
        left: transform[4] + matchStartInItem * (item.width / itemLength),
        top: y,
        width: matchLengthInItem * (item.width / itemLength),
        height: item.height
      };
      matchRects.push(rect);
      remainingMatchLength -= matchLengthInItem;
    } else if (foundStart && remainingMatchLength > 0) {
      const matchLengthInItem = Math.min(itemLength, remainingMatchLength);
      const transform = item.transform;
      const y = viewport.height - (transform[5] + item.height);
      const rect = {
        pageNumber: textMatch.pageNumber,
        left: transform[4],
        top: y,
        width: matchLengthInItem * (item.width / itemLength),
        height: item.height
      };
      matchRects.push(rect);
      remainingMatchLength -= matchLengthInItem;
    }
    if (remainingMatchLength <= 0 && foundStart) {
      break;
    }
    currentIndex += itemLength;
  }
  return mergeAdjacentRects(matchRects);
}
function mergeAdjacentRects(rects) {
  if (rects.length <= 1) return rects;
  const merged = [];
  let current = rects[0];
  if (!current) return rects;
  for (let i2 = 1; i2 < rects.length; i2++) {
    const next = rects[i2];
    if (!next) continue;
    if (Math.abs(current.top - next.top) < 2 && Math.abs(current.height - next.height) < 2) {
      current = {
        ...current,
        width: next.left + next.width - current.left
      };
    } else {
      merged.push(current);
      current = next;
    }
  }
  merged.push(current);
  return merged;
}
export {
  AnnotationHighlightLayer,
  AnnotationLayer2 as AnnotationLayer,
  AnnotationTooltip,
  CanvasLayer,
  ColoredHighlightLayer,
  CurrentPage,
  CurrentZoom,
  CustomLayer,
  HighlightLayer,
  LinkService,
  NextPage,
  Outline,
  OutlineChildItems,
  OutlineItem,
  Page,
  Pages,
  PreviousPage,
  Root,
  Search,
  SelectionTooltip,
  TextLayer2 as TextLayer,
  Thumbnail,
  Thumbnails,
  TotalPages,
  ZoomIn,
  ZoomOut,
  calculateHighlightRects,
  useAnnotations,
  usePDFPageNumber,
  usePdf,
  usePdfJump,
  useSearch,
  useSelectionDimensions
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.3.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@anaralabs_lector.js.map
